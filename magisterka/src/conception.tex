
\chapter{Koncepcja biblioteki}\label{r:koncepcja}

  W tym rozdziale zostaną przedstawione główne założenia biblioteki Parallel na tle istnijących już modeli programowania równoległego, dostępnych w języku C++.

\section{Cele biblioteki}

  Tworzeniu biblioteki Parallel przyświecały bardzo konkretne cele, których ideą przewodnią było ułatwienie wykorzystywania obliczeń równoległych w programach.
  Wymienionym poniżej celom było podporządkowane projektowanie API i implementacja biblioteki.

\subsection{Wysoka efektywność}

  Jednym z głównych powodów stosowania zrównoleglania obliczeń jest przyspieszanie ich wykonania. Dlatego sama biblioteka do zrównoleglania powinna działać szybko.
  Niedopuszczalną byłaby sytuacja, gdyby program współbieżny wykonywał się wolniej niż jego sekwencyjny odpowiednik.
  Biblioteka Parallel będzie biblioteką ogólnego zastosowania, przy pomocy, które będzie możliwe prowadzenie dowolnych obliczeń.
  Niemożliwe jest takie napisanie biblioteki ogólnej, żeby w każdej sytuacji działała bardzo wydajnie
  Dlatego, oprócz szybkiego działania mechanizmów wbudowanych w bibliotekę, niezbędne jest pozwolenie programiście na podejmowanie decyzji o takim prowadzeniu obliczeń, że ich wykonanie przy użyciu biblioteki Parallel będzie efektywne..
  
\subsection{Zwiększenie produktywności programisty}
  Problem z efektywnością programisty w przypadku pisania programów równoległych polega na tym, że takie programy są trude do pisania, stąd wymagają znacznych nakładów czasowych.
  Zrównoleglenie choćby niewielkiego fragmentu programu wymaga często znacznie więcej czasu niż napisanie jego sekwencyjnego odpowiednika.
  Być może dlatego obliczenia równoległe wykorzystywane są wyłącznie wtedy, gdy już nie ma innego sposobu osiągnięcia niezbędnego minimum wydajności programu.
  Biblioteka Parallel celuje w zmianę tego stanu rzeczy, dzięki wprowadzeniu modelu programowania równoległego, który będzie tak samo intuicyjny jak programowanie sekwencyjne.
  Dzięki czemu napisanie kodu, który działa współbieżnie, będzie prawie tak samo szybkie jak kodu sekwencyjnego, co pozwoliłoby uzyskać programistom szybsze programy przy tej samej produktywności.

\subsection{Czytelność kodu}

  Tym, co najbardziej utrudnia zrozumienie programów współbieżnych jest konieczność zrozumienia zależności pomiędzy odrębnymi równolegle działającymi częściami programu.
  Zazwyczaj te zależnośći dotyczą miejsc w kodzie, które są od siebie stosunkowo odległe.
  Mnogość niejawnych zależności i przeplotów wykonań programu sprawiają, że nawet pozornie proste operacje są trudne do poprawnego zaprogramowania.
  Jednym z bardziej wymownych przykładów popierających to stwierdzenie jest problem implementacji semafora uogólnionego przy pomocy semaforów binarnych \cite{gensem}.
  Stąd celem, który został postawiony przed biblioteką Parallel było ukrycie do takiego stopnia, do jakiego to możliwe, obecności równoległości w kodzie.
  Najważniejsze jest to, że struktura programu napisanego przy pomocy biblioteki Parallel nie powinna istotnie różnić się od struktury programu sekwencyjnego.
  Pozwoli to na uzyskanie kodu, który będzie znacznie łatwiej zrozumieć.

\subsection{Transparencja}

  Biblioteka Parallel powinna udostępniać programiście wgląd w to, w jaki sposób oblczenia równoległe będą prowadzone.
  Dzięki temu programista będzie mógł uwzględnić podczas programowania ograniczenia, które wynikają z konstrukcji biblioteki.
  Między innymi będzie mógł dostosować wielkość zlecanych fragmentów obliczeń (ziarnistość obliczeń), tak aby zmaksymalizować wydajność programu.
  
\subsection{Abstrakcja}

  Abstrakcja ukrywa niepotrzebne szczegóły implementacji przed programistą, co pozwala na zwiększenie jego produktywności.
  Używając biblioteki Parallel programista nie będzie musiał uczyć się skomplikowanego API, ponieważ uogólnione API będzie proste.

\subsection{Ograniczenie konieczności korzystania z mechanizmów komunikacji i synchronizacji procesów równoległych}

  Projektowawnie komunikacji i synchronizacji w programach współbieżnych jest czymś, co decyduje o fakcie, że programowanie równoległe jest tak trudnym zadaniem.
  Celem biblioteki Parallel jest zdjęcie w znacznym stopniu tego obciążenia z programisty.
  Komunikacja pomiędzy różnymi wątkami wykonania będzie koordynowana przez bibliotekę.
  Biblioteka nie może wyręczyć jednak programisty we wszystkim, ochrona spójności struktur danych pozostanie w rękach programisty.
  
\subsection{Przenaszalność}
  
  Jest to bardzo istotna cecha biblioteki, dzięki której kod pisany przy użyciu biblioteki Parallel będzie mógł być kompilowany i wykonywany na dowolnych platformach.
  Zostanie to osiągnięte dzięki zaprogramowaniu biblioteki w pełnej zgodności z nowym standardem języka C++ (standard C++0x).
  Użycie nowego standardu jest niezbędne ze względu na zaawansowane konstrukcje językowe potrzebne do zaprogramowania biblioteki Parallel.
  Konsekwencją tego będzie niezgodność biblioteki z wcześniejszymi standardami języka C++, ale umożliwi stworzenie lepszego, bardziej czytelnego kodu biblioteki przy użyciu nowoczesnych technik programowania w C++.

\section{Model programowania w bibliotekce Parallel}

  Model programowania przy użyciu biblioteki był tak projekowany, aby spełnić cele wyszczególnione w poprzedniej sekcji.
  Przedstawię poniżej inspirację oraz wynik końcowy pracy koncepcyjnej nad biblioteką, jak i uzasadnienie podjętych decyzji.

\subsection{Inspiracja}

  Powstanie biblioteki zostało zainspirowane biblioteką do prowadzenia obliczeń równoległych w języku Haskell, Parallel Haskell\cite{parhas}.
  Ta biblioteka pozwala w sposób bardzo intuicyjny obliczać dwa wyrażenia równolegle.
  Oto przykład funkcji obliczającej w sposób równoległy n-tą liczbę Fibonacciego:
  \begin{verbatim}
    import Control.Parallel

    nfib :: Int -> Int
    nfib n | n <= 1 = 1
       | otherwise = par n1 (seq n2 (n1 + n2))
                     where n1 = nfib (n-1)
                           n2 = nfib (n-2)
  \end{verbatim}
  
  Analogiczny program sekwencyjny wyglądałby następująco:
  \begin{verbatim}
    import Control.Parallel

    nfib :: Int -> Int
    nfib n | n <= 1 = 1
       | otherwise = (n1 + n2)
                     where n1 = nfib (n-1)
                           n2 = nfib (n-2)
  \end{verbatim}
  
  W Haskellu funkcja \verb|par| wskazuje, że wyliczenie równoległe może być korzystne i w czasie wykonania podejmowana jest decyzja o sposobie wyliczenia.
  Ta konstrukcja pokazuje z jak zadziwiającą prostotą można pisać programy równoległe.
  
\subsection{Zlecanie obliczeń}

  UWAGA!!! We wszystkich przedstawionych poniżej fragmentach kodu przyjęto, że zostały napisane z deklaracją \verb|using parallel;|.\\

  Zlecanie równoległego wykonania obliczeń powinno jak najmniej ingerować w sekwencyjny kod programu dla zachowania jego intuicyjności.
  Do oznaczenia wyrażenia, które ma zostać wykonane równolegle wykorzystywana jest funkcja \verb|evaluate|, przyjmująca jako argument wyrażenie do wykonania.
  Obliczenie przekazanego wyrażenia odbędzie się równolegle.
  W tej chwili czytelnik dobrze zaznajomiony z semantyką języka C++ zapewne zauważył problem związany z przekazaniem wyrażenia do wykonania.
  Jeśli byłoby ono przekazane w standardowej formie w języku C++, to zostałoby wyliczone i dopiero wtedy przekazane do funkcji \verb|evaluate|, ponieważ w języku C++ wszystkie wyrażenia wyliczane są gorliwie.
  Dlatego niezbędne było zaprojektowanie uleniwionego sposobu przekazywania wyrażenia do funkcji \verb|evaluate|.
  
\subsubsection{Leniwe wyrażenia w języku C++}

  W pierwszej chwili stworzenie leniwego wyrażenia w języku C++ może wydawać się niemożliwe lub bardzo trudne. 
  Domyśla semantyka jest gorliwe, nie ma żadnych słów kluczowych pozwalających na dodanie leniwości, C++ nie pozwala również na rozszerzenie składni języka.
  Rozwiazanie problemu leniwych wyrażeń w języku C++ znajduje się w książce \textit{More C++ Idioms}\cite{idioms}, która przedstawia idiom C++ szablonu wyrażenia (z ang. Expression Template).
  
%\paragraph{Idiom C++ szablonu wyrażenia}
  
  Idiom szablonu wyrażenia wykorzystuje inny idiom Rekurencyjnego Składania Typów (z ang. Recursive Type Composition). 
  Polega on na tym, że szablon typu zawiera pola, których typem jest jest instancja tego samego szablonu typów.
  W tens sposób powstaje drzewo reprezentujące wyrażenie w postaci drzewa typów, taka konstrukcja nazywana jest Abstrakcyjnym Drzewem Syntaktycznym (z ang. Abstract Syntax Tree - AST) typów.
  W takiej konstrukcji w liściach drzewa znajdują się terminale wyrażenia, natomiast w węzłach pośrednich operatory użyte w wyrażeniu.
  Oczywiście każdy operator reprezentowany jest przez odpowiedni typ, z odpowiednio zaimplementowaną funkcją aplikującą operator.
  W celu dokładnego zrozumienia sposobów obliczeń na typach w języku C++ zalecana jest lektura książki \cite{temguide}.
  
%\paragraph{Leniwe wyrażenie przy pomocy idiomu wyrażenia}
  
  Mając implementację tworzenia szablonów wyrażeń stworzenie wyrażenia wyliczanego leniwie jest już stosunkowo proste.
  Naturalnie, nie można przekazać całego wyrażenia w oryginalnej formie do funkcji tworzącej leniwe wyrażenie, ponieważ napotkalibyśmy identyczny problem jak opisano powyżej.
  Przekazywane wyrażenie najpierw zostałoby wyliczone, a potem przekazane do funkcji uleniwiającej wyrażenie.
  Leniwość musi zostać ``zaszczepiona'' na niższym poziomie do wyrażenia. Jeszcze przed tym, gdy jakikolwiek operator z wyrażenia zostanie zastosowany.
  Jest to możliwe, dzieki oznaczeniu terminali wyrażenia jako elementów wyrażenia leniwego (na przykład w ten sposób \verb|lazy_val(4)|).
  Kolejne etap tworzenia szablonu wyrażenia wykonywałby się dzięki przeciążaniu operatorów, gdyż typ wynikowy funkcji generycznej \verb|lazy_val| miałby przeciążone wszystkie operatory.
  Typy wynikowe przeciążonych operatórów miałyby identyczną własność i w ten sposób osiągnelibysmy zamierzony efekt stworzenia Abstrakcyjnego Drzewa Syntaktycznego reprezentującego leniwe wyrażenie.
  
  Tym sposobem pokazałem, że na poziomie koncepcyjnym jak powinna wyglądać implementacja leniwego wyliczania wyrażeń w języku C++.
  Pomysł zostanie wykorzystany w trakcie implementacji biblioteki.
  
\subsubsection{Alternatywne rozwiązanie}

  Parafrazując popularne powiedzienie można powiedzieć, że nie ma rozwiązań niezastąpionych.
  Oczywiście istnieje alternatywa do przekazywania wyrażenia do ewaluacji w formie leniwej.
  Podobny efekt można uzyskać stosując obiekty funkcyjne, które reprezentowałyby dane wyrażenie.
  Istnieje jednak istotny powód, dla którego zostało wybrane pierwsze z przedstawionych rozwiązań.
  Leniwe wyrażenia mają znacznie bardziej intuicyjną składnię, natomiast tworzenie odpowiednich obiektów funkcyjnych wymaga znajomości stosownych bibliotek.
  Przykładami są Boost.Lambda, Boost.Function i Boost.Bind, jednakże pomimo tego, że są to jedne z najlepszych bibliotek w swojej klasie ich składnia jest zdecydowanie nieintuicyjna i nieczytelna, w przypadku pisania rozbudowanego wyrażenia.
  Szczególnie problematyczny jest zapis zagniężdżonych funkcji, w tym operatorów.
  Następujący kawałek kodu nie należy do czytelnych:
\begin{verbatim}
  bind(f, bind(operator+,5,4)); //f(5+4)
\end{verbatim}
  Zamiast bardziej intuicyjnego:
\begin{verbatim}
  lazy_fun(f)( lazy_val(5) + lazy_val(4) );
\end{verbatim}
  Tak naprawdę wystarczyłoby
\begin{verbatim}
 f(lazy_val(5)+4);
\end{verbatim}
  gdyż \verb|lazy_val(5)| "zaszczepiłoby" leniwość na najniższym poziomie w drzewie wyrażenia, która następnie propagowałaby się w stronę potomków i rodzeństwa tego węzła w drzewie wyrażenia.

  Stąd ze względu na znacznie bardziej intuicyjną składnię dla przekazywania obliczeń do wykonania równoległego zostały wybrane leniwe wyrażenia.
  
\subsubsection{Funkcja \texttt{evaluate}}

  Funkcja \texttt{evaluate} jest główną funkcją z API dostępnego dla programisty.
  Funkcja służy do zlecenia wykonania obliczeń równoleglych.
  W ciele funkcji powinno znaleźć się przekazanie wyrażenia w formie leniwej do mechanizmu ewaluacyjnego.
  Funkcja powinna udostępniać możliwość sprawdzenia wyniku obliczenia.
  Przekazywanie wyników obliczeń przez bibliotekę Parallel został omówiony w jednej z następnych podsekcji.
  
\subsection{Wykonanie zadań}

  W tej podsekcji zostanie omówiony mechanizm wyliczania wyrażeń w bibliotece Parallel.
  Została podjęta decyzja, iż wyrażenia przeznaczone do wyliczenia równoległęgo będą obliczane w wątkach działających w ramach programu korzystającego z biblioteki Parallel.
  
\subsubsection{Wątki-pracownicy}

  Wyrażenie przekazane do funkcji \texttt{evaluate} po zamienieniu na leniwe wyrażenie będzie przekazywane do wyliczenia.
  Wyrażenia będę w obliczane w bibliotece Parallel w wątkach zwanych wątkami-pracownikami.
  Jedynym zadaniem tych wątków będzie oczekiwanie na zadanie do wykonania, a następnie wyliczenie leniwego wyrażenia z odpowiednim przekazaniem wyniku.
  W tym modelu wątki-pracownicy będą konsumentami zadań do wykonania, natomiast kod użytkownika będzie produkował te zadania.
  
  
\subsubsection{Ograniczenia mechanizmu ewaluacji}

  W związku ze sposobem przekazywania wyrażeń do obliczenia, możliwości projektowania mechanizmu ewaluacyji były dość poważnie ograniczone.
  W ogólności moglibyśmy wyobrazić sobie sytuację, w której wyrażenie z programu działającego na jednym komputerze byłoby przekazywane do wyliczenia do innych programół lub nawet do innych komputerów, w celu jeszcze lepszego zrównoleglenia wykonania programu i uzyskania większego przyspieszenia.
  W przypadku biblioteki parallel wystąpiło kilka ograniczeń, które uniemożliwiły zaprojektowanie ogólniejszego mechanizmu obliczeń.
  
  Migracja kodu (taka jak zostałą opisana w książce \cite{dissys}) nie jest wspierana przez język C++, ponieważ kod kompilowany jest do natywnego kodu maszynowego, a nie kodu pośredniego.
  Nie ma możliwości zserializowania fragmentu obliczeń i przesłania do wykonania na innym komputerze, o nieznanej architekturze.
  W przeciwieństwie do języka C++ to jest wykonalne w języku Java.
  
  Alternatywą dla wsparcia języka dla migracji kodu jest rozszerzenie narzędzi kompilujących o narzędzia automatycznie generujące kod dla klienta (programu zlecającego obliczenia) i serwera (programu wykonującego obliczenia).
  To już zaczyna przypominać mechanizm RPC i rodzi szereg innych problemów również opisanych w \cite{dissys}.
  Implementacja takiego modelu prowadzenia obliczeń w bibliotece Parallel wykraczałaby poza ramy nakreślonej pracy oraz sprawiłaby, iż Parallel przestałaby być zwykłą biblioteką, 
  której można użyć na każdej platformie zgodnej ze standardem C++0x.
  
  Kolejne z ograniczeń jest związane z obecnością w wyrażeniu przekazywanym do obliczenia wartości typu referencje lub wskaźniki, które są ściśle zależne od przestrzeni adresowej programu. 
  Przesłanie ich nawet do innego programu na tym samym komputerze nie miałoby sensu, gdyż powodowałoby błędy w dostępie do pamięci.
  Obejście tego problemu oferuje mechanizm pamięci współdzielonej, ale powoduje znaczny narzut na dostęp do pamięci współdzielonej.
  Natomiast narzut na dostęp do obiektów współdzielonych pomiędzy odseparowanymi fizycznie komputerami byłby ogromny.
  
  Wymienione powyżej ograniczenia uzasadniają podjęcie decyzji o przyjęcie dla biblioteki Parallel modelu obliczania wyrażeń opartego o wątki działające w ramach programu zlecającego obliczenia.
  
\subsubsection{Działanie mechanizmu ewaluacji}
  
  Ewaluacja wyrażeń przekazanych do obliczenia będzie odbywała się zgodnie z powszechnie znanym modelem w dziedzinie współbieżności, producent-konsument.
  Producentem wyrażeń będzie kod programu korzystającego z biblioteki Parallel i przekazujący wyrażenia przy pomocy funkcji \texttt{evaluate}.
  Natomiast konsumentem będą wątki-pracownicy biblioteki Parallel, których jedynym zadaniem będzie oczekiwanie na zadania (wyrażenia do ewaluacji) i ich wykonywanie.
  Ze względu na efektywność wykorzystany zostanie wzorzec puli wątków (thread pool opisany w \cite{threadpool}).
  Zatem wątek nie będzie tworzony dla wykonania każdego zadania, a będzie istniała grupa wątkół dedykowanych do wykonywania obliczeń, która będzie zaalokowana w programie tak długo jak program będzie korzystał z biblioteki Parallel.
  O liczbie wątków będzie decydował użytkownik, gdyż ich liczba może mieć znaczący wpływ na wydajność programu, a nie istnieje optymalna liczba wątków dla każdego rodzaju zastosowania biblioteki Parallel.
  Standardowo w tym modelu wyrażenia będą trafiały do kolejki zadań, w której będą oczekiwały na wyliczenie.
  
  Może się zdarzyć, że wyrażenie nie zostanie wyliczone do momentu gdy będzie potrzebne w programie, który przekazał je do obliczenia.
  W tej sytuacji biblioteka Parallel reaguje w takie sposób, by nie blokować bez przyczyny programu.
  Program dotarłby do takiego miejsca, że potrzebuje wyliczonego wyrażenia przekazanego do Parallel, a nie zostało jeszcze wykonane, program musiałby oczekiwać na wykonanie obliczeń.
  Skoro program nie ma nic innego do wykonania to wątek programu sam może wyliczyć wyrażenie, odpowiednio informując bibliotekę Parallel, aby wyrażenie nie zostało wykonane kilkakrotnie, 
  gdyż nierozsądne byłoby narzucanie ograniczenia nakazującego, żeby wyrażenia przekazywane do biblioteki Parallel były idempotentne.
  Całością procesu alternatywnego wyliczania obliczenia przez wątek programu powinna zarządzać biblioteka, tak aby nie było to zauważalne dla programisty.
  
  Jednym z rozszerzeń mechanizmu ewaluacji mogłoby być
  Zależności danych i równoważenie obciążenia wątków
  
  

\subsection{Sposób przekazywania wyniku}

\section{Inne modele programowania równoległego w języku C++}

\section{Analiza cech biblioteki}