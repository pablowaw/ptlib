
\chapter{Koncepcja biblioteki}\label{r:koncepcja}

  W tym rozdziale zostan± przedstawione g³ówne za³o¿enia oraz szkic projektu biblioteki Parallel. 
  Ponadto biblioteka Parallel zostanie zestawiona z istniej±cymi bibliotekami do programowania równoleg³ego w celu pokazania ró¿nic i uzasadnienia potrzeby stworzenia nowej biblioteki.

\section{Cele biblioteki}\label{s:cele}

  Tworzeniu biblioteki Parallel przy¶wieca³y jasno sprecyzowane cele, których ide± przewodni± by³o u³atwienie wykorzystywania obliczeñ równoleg³ych w programach.
  Wymienionym poni¿ej celom by³o podporz±dkowane projektowanie API i implementacja biblioteki.

\subsection{Wysoka efektywno¶æ}

  Jednym z g³ównych powodów stosowania zrównoleglania obliczeñ jest przyspieszanie ich wykonania. 
  Zatem sama biblioteka do zrównoleglania powinna dzia³aæ szybko.
  Niedopuszczaln± by³aby sytuacja, gdyby program wspó³bie¿ny wykonywa³ siê wolniej ni¿ jego sekwencyjny odpowiednik.
  Biblioteka Parallel bêdzie bibliotek± ogólnego zastosowania, przy pomocy, której bêdzie mo¿liwe prowadzenie dowolnych obliczeñ.
  W zwi±zku z tym, nie ma mo¿liwo¶ci zoptymalizowania biblioteki pod k±tem prowadzenia jednego z góry znanego typu obliczeñ.
  Dlatego, oprócz szybkiego dzia³ania mechanizmów wbudowanych w bibliotekê, niezbêdne jest pozwolenie programi¶cie na podejmowanie decyzji o takim prowadzeniu obliczeñ, 
  ¿e ich wykonanie przy u¿yciu biblioteki Parallel bêdzie efektywne.
  Kluczow± rolê odgrywa odpowiedni podzia³ zadañ przez programistê.
  
\subsection{Zwiêkszenie produktywno¶ci programisty}

  Problem z produktywno¶ci± programisty w przypadku pisania programów równoleg³ych polega na tym, ¿e takie programy s± trude do napisania, wiêc wymagaj± znacznych nak³adów pracy programistów.
  Zrównoleglenie choæby niewielkiego fragmentu programu wymaga znacznie wiêcej czasu ni¿ napisanie jego sekwencyjnego odpowiednika.
  Byæ mo¿e dlatego obliczenia równoleg³e wykorzystywane s± wy³±cznie wtedy, gdy ju¿ nie ma innego sposobu osi±gniêcia niezbêdnego minimum wydajno¶ci programu.
  Biblioteka Parallel celuje w zmianê tego stanu rzeczy poprzez wprowadzenie modelu programowania równoleg³ego, który bêdzie tak intuicyjny jak programowanie sekwencyjne.
  Dziêki temu napisanie kodu, który dzia³a wspó³bie¿nie, bêdzie w wielu przypadkach prawie tak samo szybkie jak kodu sekwencyjnego, co pozwoli³oby uzyskaæ programistom szybsze programy przy zbli¿onej produktywno¶ci ich pracy.

\subsection{Czytelno¶æ kodu}

  Tym, co najbardziej utrudnia zrozumienie programów wspó³bie¿nych jest konieczno¶æ zrozumienia zale¿no¶ci pomiêdzy odrêbnymi równolegle dzia³aj±cymi czê¶ciami programu.
  Zazwyczaj te zale¿no¶ci dotycz± miejsc w kodzie, które s± od siebie stosunkowo odleg³e.
  Mnogo¶æ niejawnych zale¿no¶ci i przeplotów wykonañ programu sprawiaj±, ¿e nawet pozornie proste operacje s± trudne do poprawnego zaprogramowania, a przyczyny ewentualnych b³êdów s± bardzo trudne do zidentyfikowania.
  Jednym z bardziej wymownych przyk³adów popieraj±cych to stwierdzenie jest problem implementacji semafora uogólnionego przy pomocy semaforów binarnych \cite{gensem}, 
  którego b³êdne rozwi±zania pojawia³y siê w publikacjach naukowych i nawet przez kilka lat by³y uwa¿ane za poprawne.
  St±d celem, który zosta³ postawiony przed bibliotek± Parallel by³o stworzenie takiego modelu obliczeñ, w którym obliczenia równoleg³e prowadzone by³yby w sposób czytelny.
  Oznacza to, i¿ miejsca wykorzystania równoleg³o¶ci powinny byæ wyra¼nie widoczne i ³atwe do odnalezienia, a sam zapis nie powinnien komplikowaæ kodu.
  Najwa¿niejsze jest to, ¿e struktura programu napisanego przy pomocy biblioteki Parallel nie powinna istotnie ró¿niæ siê od struktury programu sekwencyjnego.
  Pozwoli to na uzyskanie kodu, który bêdzie znacznie ³atwiej zrozumieæ.

\subsection{Transparencja}

  Biblioteka Parallel powinna udostêpniaæ programi¶cie wgl±d w to, w jaki sposób obliczenia równoleg³e bêd± prowadzone.
  Dziêki temu programista bêdzie móg³ uwzglêdniæ podczas programowania specyfikê biblioteki.
  Miêdzy innymi bêdzie móg³ dostosowaæ wielko¶æ zlecanych fragmentów obliczeñ (ziarnisto¶æ obliczeñ), tak aby zmaksymalizowaæ wydajno¶æ programu.
  
\subsection{Abstrakcja}

  Abstrakcja ukrywa niepotrzebne szczegó³y implementacji przed programist±, co pozwala na zwiêkszenie jego produktywno¶ci.
  Biblioteka powinna ofertowaæ proste ogólne API, tak aby programista móg³, po zapoznaniu siê z funkcjami oferowanymi przez bibliotekê, w krótkim czasie przyst±piæ do korzystania z Parallel.

\subsection{Ograniczenie konieczno¶ci korzystania z mechanizmów komunikacji i synchronizacji procesów równoleg³ych}

  Projektowawnie komunikacji i synchronizacji w programach wspó³bie¿nych jest czym¶, co decyduje o fakcie, ¿e programowanie równoleg³e jest tak trudnym zadaniem.
  Celem biblioteki Parallel jest zdjêcie w znacznym stopniu tego obci±¿enia z programisty.
  Komunikacja pomiêdzy ró¿nymi w±tkami wykonania bêdzie koordynowana przez bibliotekê.
  Biblioteka nie mo¿e wyrêczyæ jednak programisty we wszystkim, ochrona spójno¶ci struktur danych programu pozostanie w rêkach programisty.
  
\subsection{Przenaszalno¶æ}
  
  Jest to bardzo istotna cecha biblioteki, dziêki której kod pisany przy u¿yciu biblioteki Parallel bêdzie móg³ byæ kompilowany i wykonywany na dowolnych platformach.
  Zostanie to osi±gniête dziêki zaprogramowaniu biblioteki w pe³nej zgodno¶ci z przysz³ym standardem jêzyka C++ (standard C++0x).
  U¿ycie nowego standardu jest niezbêdne ze wzglêdu na zaawansowane konstrukcje jêzykowe potrzebne do zaprogramowania biblioteki Parallel.
  Konsekwencj± tego bêdzie niezgodno¶æ biblioteki z wcze¶niejszymi standardami jêzyka C++, ale umo¿liwi stworzenie lepszego, bardziej czytelnego kodu biblioteki przy u¿yciu nowoczesnych technik programowania w C++.


\section{Prezentacja idei biblioteki Parallel}

  Niniejsza sekcja przedstawia inspiracjê oraz wynik koñcowy pracy koncepcyjnej nad bibliotek±.
  Zostan± zarysowane wysokopoziomowa architektura biblioteki oraz funkcjonowanie biblioteki z punktu widzenia programisty-u¿ytkownika.

\subsection{Inspiracja}

  Powstanie biblioteki zosta³o zainspirowane bibliotek± do prowadzenia obliczeñ równoleg³ych w jêzyku Haskell, Parallel Haskell\cite{parhas}.
  Ta biblioteka pozwala w sposób bardzo intuicyjny obliczaæ dwa wyra¿enia równolegle.
  Oto przyk³ad funkcji obliczaj±cej w sposób równoleg³y n-t± liczbê Fibonacciego:
  \begin{lstlisting}[language=Haskell]
    import Control.Parallel

    nfib :: Int -> Int
    nfib n | n <= 1 = 1
       | otherwise = par n1 (seq n2 (n1 + n2))
                     where n1 = nfib (n-1)
                           n2 = nfib (n-2)
  \end{lstlisting}
  
  Analogiczny program sekwencyjny wygl±da³by nastêpuj±co:
  \begin{lstlisting}[language=Haskell]
    import Control.Parallel

    nfib :: Int -> Int
    nfib n | n <= 1 = 1
       | otherwise = (n1 + n2)
                     where n1 = nfib (n-1)
                           n2 = nfib (n-2)
  \end{lstlisting}
  
  W Haskellu funkcja \verb|par| wskazuje, ¿e wyliczenie dwóch wyra¿eñ mo¿e odbyæ siê równolegle i w czasie wykonania podejmowana jest decyzja o sposobie wyliczenia.
  Obliczenia odbywaj± siê równolegle, gdy jest to bardziej efektywne od wykonania sekwencyjnego.
  Ta konstrukcja pokazuje z jak zadziwiaj±c± prostot± mo¿na pisaæ programy równoleg³e.
  W Haskellu wystarczy dodaæ jedno s³owo, aby oznaczyæ wyra¿enie jako przeznaczone do zrównoleglenia.
  Taka by³a pierwotna inspiracja dla zbudowania biblioteki Parallel.
  Przekazanie wyra¿enia do odpowiedniej funkcji powinno poskutkowaæ jego zrównolegleniem.
  
\subsection{Zlecanie obliczeñ}\label{ss:zlecanie}

  Zlecanie równoleg³ego wykonania obliczeñ powinno jak najmniej ingerowaæ w sekwencyjny kod programu dla zachowania jego intuicyjno¶ci
  \footnote{Nie twierdzê, i¿ jedynie sekwencyjny kod programu mo¿e byæ intuicyjny, jednak praktyka pokazuje, ¿e zrozumienie programu, 
  który zosta³ zapisany jako kilka jednocze¶nie wykonywanych ci±gów instrukcji jest znacznie trudniejsze od zrozumienia programu sekwencyjnego.}.
  Do oznaczenia wyra¿enia, które ma zostaæ wykonane równolegle bêdzie s³u¿y³a funkcja \verb|eval|, przyjmuj±ca jako argument wyra¿enie do wykonania.
  Sk³adnia wyra¿eñ powinna byæ jak najbardziej zbli¿ona do sk³adni jêzyka C++, po to, aby konstruowanie wyra¿eñ by³o ³atwe dla programisty.
  Idealnie by³oby, gdyby programista móg³ przekazaæ wyra¿enie w jego standardowej postaci w jêzyku C++, czyli w nastêpuj±cy sposób:
  \begin{lstlisting}[numbers=none, frame=none]
    parallel::eval(fibo(40));
  \end{lstlisting}
  W tej chwili czytelnik dobrze zaznajomiony z semantyk± jêzyka C++ móg³ dostrzec pewien problem, który jest zwi±zany z przekazaniem wyra¿enia do wykonania.
  W podanym przyk³adzie takie wyra¿enie najpierw zosta³oby wyliczone, poniewa¿ jêzyk C++ posiada gorliw± semantykê wyliczania wyra¿eñ, a dopiero potem by³oby przekazane do funkcji \verb|eval|.
  Zatem funkcja \feval otrzyma³aby gotowy wynik i ¿adne równoleg³e obliczenia nie by³yby ju¿ potrzebne.
  Takiej sytuacji nale¿y unikn±æ poprzez zaprojektowanie specjalnego sposobu przekazywania wyra¿eñ do funkcji \feval.
  Zabieg, który nale¿y zastosowaæ nazywa siê uleniwieniem wyra¿enia i polega na odroczeniu obliczenia warto¶ci wyra¿enia do momentu, gdy ta warto¶æ bêdzie potrzebna.
  Wyra¿enie leniwe nie jest wyliczane w miejscu pojawienia siê.
  Dziêki zastosowaniu takiej metody wyra¿enie, które ma byæ wyliczone równolegle pojawia siê w kodzie tam, gdzie jest to najwygodniejsze, w jawnej postaci, a potem mo¿e zostaæ przekazane do mechanizmu ewaluacji biblioteki Parallel.
  
\subsubsection{Leniwe wyra¿enia w jêzyku C++}

  Stworzenie leniwego wyra¿enia w jêzyku C++ nie wydaje siê prostym zadaniem.
  Domy¶lna semantyka obliczeñ jest gorliwa, nie ma s³ów kluczowych pozwalaj±cych na dodanie leniwo¶ci, C++ nie pozwala równie¿ na rozszerzenie sk³adni jêzyka.
  Wskazówka do rozwiazanie problemu leniwych wyra¿eñ w jêzyku C++ znajduje siê w ksi±¿ce \textit{More C++ Idioms}\cite{idioms}, która przedstawia idiom C++ szablonu wyra¿enia (z ang. Expression Template).
  Idea stworzenia szablonu wyra¿enia polega na reprezentacji wyra¿enia przez zbudowanie odpowiedniego drzewa typów, które jest Abstrakcyjnym Drzewem Syntaktycznym (z ang. Abstract Syntax Tree - AST) wyra¿enia.
  Dok³adny opis zastosowanej metody znajduje siê w rozdziale po¶wiêconym implementacji biblioteki.
  
  \subsubsection{Funkcja \texttt{eval}}\label{sss:eval}

  Jeszcze s³owo w rozdziale przedstawiaj±cym koncepcje biblioteki nale¿y siê funkcji \feval, która jest g³ówn± funkcj± z API biblioteki Parallel.
  Funkcja s³u¿y do zlecania wykonania równoleg³ego wyliczania wyra¿eñ, które nastêpnie s± przekazywane w formie leniwej do mechanizmu wykonawczego.
  Warto¶æ zwracana przez funkcjê jest uchwytem, którego mo¿na u¿yæ do sprawdzenia wyniku obliczenia.
  Przekazywanie wyników obliczeñ przez bibliotekê Parallel zosta³o omówione w sekcji \nameref{s:koncepcja_wynik}.
  
\subsection{Wykonanie zadañ}\label{ss:wykonywanie}

  W tej podsekcji zostanie omówiony mechanizm wyliczania wyra¿eñ w bibliotece Parallel po przekazaniu ich do funkcji \texttt{eval}.
  Jest to serce biblioteki, dziêki któremu biblioteka potrafi pe³niæ swoje funkcje.
  
  \subsubsection{Dzia³anie mechanizmu ewaluacji}
  
  Ewaluacja wyra¿eñ przekazanych do obliczenia bêdzie odbywa³a siê zgodnie ze schematem producent-konsument.
  Producentem wyra¿eñ bêdzie kod programu korzystaj±cego z biblioteki Parallel i przekazuj±cy je do funkcji \texttt{eval}.
  Wyra¿enia te trafiaj± do kolejki, w której bêd± oczekiwa³y na wyliczenie.
  Natomiast konsumentem bêd± w±tki-pracownicy biblioteki Parallel, których jedynym zadaniem bêdzie oczekiwanie na zadania (wyra¿enia do ewaluacji), pobieranie ich z kolejki i wykonywanie.
  Ze wzglêdu na efektywno¶æ wykorzystany zostanie wzorzec puli w±tków (z ang. thread pool opisany w \cite{threadpool}).
  Zatem w±tek nie bêdzie tworzony dla wykonania ka¿dego zadania, a bêdzie istnia³a grupa w±tków dedykowanych do wykonywania obliczeñ, 
  która bêdzie zaalokowana w programie tak d³ugo, jak d³ugo program bêdzie korzysta³ z biblioteki Parallel.
  O liczbie w±tków bêdzie decydowa³ u¿ytkownik, gdy¿ ich liczba mo¿e mieæ znacz±cy wp³yw na wydajno¶æ programu, a nie istnieje optymalna liczba w±tków dla ka¿dego rodzaju zastosowania biblioteki Parallel.
  Standardowo w tym modelu wyra¿enia bêd± trafia³y do kolejki zadañ, w której bêd± oczekiwa³y na wyliczenie.
  
  Mo¿e siê zdarzyæ, ¿e wyra¿enie nie zostanie wyliczone do momentu, gdy jego wynik bêdzie potrzebny.
  W tej sytuacji biblioteka Parallel reaguje w taki sposób, by nie blokowaæ programu bez przyczyny.
  G³ówny w±tek programu dotar³szy do takiego miejsca musia³by oczekiwaæ na wykonanie obliczeñ.
  Lecz skoro nie ma nic innego do wykonania, to mo¿e sam wyliczyæ wyra¿enie, odpowiednio informuj±c bibliotekê Parallel, aby porzuci³a ewaluacjê danego wyra¿enia.
  Ca³o¶ci± procesu alternatywnego wyliczania zarz±dza biblioteka, wiêc nie jest to zauwa¿alne dla programisty.
  
  Jednym z rozszerzeñ mechanizmu ewaluacji mog³oby byæ dodanie automatycznego dostosowywania liczby w±tków w puli do intensywno¶ci prowadzonych obliczeñ.
  W pierwszej wersji biblioteki nie przewidziano w projekcie takiej funkcjonalno¶ci.
  
  Warto zauwa¿yæ, ¿e w bibliotece nie wystêpuje problem równowa¿enia obci±¿enia ró¿nych w±tków, gdy¿ wszystkie w±tki nale¿±ce do puli s± identycznie i dziêki wykorzystaniu wspólnej kolejki zadañ, 
  obci±¿enie jest równowa¿one samoczynnie.
  W±tek koñcz±c pracê nad jednym zadaniem siêga do kolejki po nastêpne.
  
\subsubsection{Mechanizmy synchronizacji}

  Dla poprawno¶ci dzia³ania biblioteki niezbêdne by³o zaimplementowanie mechanizmów synchronizacji pomiêdzy w±tkami biblioteki a kodem programu. 
  Zosta³y one opisane w sekcji \nameref{s:ewaluacja}.
  U¿ywaj±c biblioteki Parallel programista nie musi martwiæ siê o synchronizacjê dzia³ania biblioteki Parallel.
  
  Biblioteka nie mo¿e jednak przewidzieæ zale¿no¶ci w kodzie programu, dlatego ochrona danych, na których dokonywane s± obliczenia pozostaje w rêkach programisty.
  Parallel nie narzuca ¿adnych ograniczeñ, co do korzystania w kodzie zrównoleglanych wyra¿eñ instrukcji dostêpu do struktur danych, z których korzysta wiele w±tków jednoczesnie.
  W tej sytuacji programista musi zadbaæ o odpowiednie umieszczenie sekcji krytycznych w kodzie obliczanych wyra¿eñ, tak aby program by³ bezpieczny i ¿ywotny.
  
\subsection{Sposób przekazywania wyniku}\label{s:koncepcja_wynik}

  Kod korzystaj±cy z biblioteki Parallel powinien wygl±daæ naturalnie.
  Skoro do funkcji \texttt{eval} przekazujemy wyra¿enie, to naturalnym oczekiwaniem jest to, ¿e w wyniku ewaluacji otrzymamy warto¶æ tego wyra¿enia.
  Problem tkwi w tym, ¿e je¶li warto¶æ by³aby zwracana w momencie powrotu z funkcji \texttt{eval} to otrzymaliby¶my \textit{de facto} program sekwencyjny, choæ roz³o¿ony na kilka w±tków,
  nie by³oby mo¿liwo¶ci wykorzystania korzy¶ci z równoleg³ego prowadzenia obliczeñ na wielu w±tkach.
  Dlatego wywo³anie obliczenia wyra¿enia przez funkcjê \feval biblioteki Parallel nie zwraca wyniku natychmiast.
  W momencie powrotu z funkcji \feval bêdzie znany jedynie typ wyra¿enia, a nie jego warto¶æ.
  Warto¶æ zostanie obliczona pó¼niej przez mechanizm ewaluacji biblioteki Parallel, a kod programu przechodzi do kolejnych instrukcji.
  Program mo¿e w dowolnym momencie poprosiæ o obliczon± warto¶æ wyra¿enia.
  
  To podej¶cie nazywa siê komunikacj± asynchroniczn± i czêsto pojawia siê w kontek¶cie programowania wspó³bie¿nego.
  Wykorzystuj± je takie technologie jak asynchroniczne zdalne wywo³anie procedur b±d¼ Message Passing Interface.
  Jego przeciwieñstwem, w którym wynik funkcji jest zwracany w momencie powrotu z funkcji wywo³uj±cej równoleg³e obliczenie, jest komunikacja synchroniczna.
  Wybór asynchronicznego sposobu zwracania wyniku pozwala na nastêpuj±ce optymalizacje:
  \begin{itemize}
   \item Gdy w±tek g³ówny nie wymaga wyniku ani informacji o zakoñczeniu zadania, mo¿e przej¶æ do wykonywania kolejnych instrukcji.
   \item W±tek g³ówny mo¿e uruchomiæ kilka równoleg³ych obliczeñ jednocze¶nie.
   \item W±tek g³ówny mo¿e uruchomiæ obliczenia, wykonywaæ inne instrukcje i odebraæ wynik pó¼niej, gdy bêdzie potrzebowa³. 
  \end{itemize}
  
\subsubsection{Omówienie asynchronicznych sposobów zwracania wyniku}
  Programowanie u¿ywaj±c komunikacji asynchronicznej jest trudniejsze, gdy¿ programista musi w odpowiedni sposób ni± zarz±dzaæ.
  Generalnie istniej± dwa asynchroniczne sposoby zwracania wyniku.
  Oba zosta³y opisane w ksia¿ce \cite{dissys} w rozdziale dotycz±cym Asychronicznego Zdalnego Wywo³ania Procedur (z ang. Asychronous RPC).
  
  Pierwszy z nich to sposób jawny, w którym asynchroniczne wywo³anie pewnej funkcji zwraca identyfikator wyniku.
  Nastêpnie w±tek, który wywo³a³ tê funkcjê mo¿e odpytywaæ proces wykonuj±cy obliczenie o wynik (z ang. polling) przy pomocy identyfikatora.
  
  Drugi sposób jest niejawny, poniewa¿ kod programu nie obs³uguje zwracanego wyniku wprost.
  Proces wykonuj±cy obliczenie wywo³uje pewn± funkcjê, której przekazuje obliczony wynik i ta funkcja odpowiada za dalsze przetwarzanie wyniku.
  Jest to tak zwane zwrotne wywo³anie funkcji (z ang. callback), a ten wzorzec projektowy okre¶lany jest jako przetwarzanie sterowane wydarzeniami (z ang. event-driven processing).
  
  W kontek¶cie projektowania biblioteki Parallel natychmiast odrzucone zosta³o wykorzystanie drugiego z opisanych sposobów, poniewa¿ sta³by on w zdecydowanej sprzeczno¶ci z celami biblioteki.
  W przypadku niejawnego sposobu przetwarzania wyniku, kod programu u¿ywaj±cego biblioteki Parallel sta³by siê mniej czytelny i trudniejszy do analizy.
  Zlecenie obliczenia i odebranie wyniku by³oby opisane przez dwa ró¿ne odleg³e od siebie miejsca w kodzie.
  
  Zdecydowanie bli¿szy idei biblioteki Parallel jest sposób pierwszy.
  Jednak¿e zdecydowana wiêkszo¶æ tego typu rozwi±zañ zrzuca na programistê obowi±zek aktywnego odpytywania o wynik.
  Nie jest to rozwi±zaniem z³ym, ale zmusza programistê do zaprogramowania dodatkowych czynno¶ci.
  Na przyk³ad, programista musi obs³u¿yæ sytuacje, gdy wynik ju¿ jest dostêpny lub gdy obliczenie nie zosta³o jeszcze wykonane.
  Aby upro¶ciæ u¿ycie biblioteki Parallel warto by³o poszukaæ innego rozwi±zania.
  
\subsubsection{Emulowanie synchronicznego zwracania wyniku}  

  Rozwi±zanie zaprojektowane dla biblioteki Parallel opiera siê na asynchronicznym zwracaniu wyniku, ale asynchroniczno¶æ jest ukryta przed programist±.
  Z jego punktu widzenia kod programu dzia³a tak, jakby wynik zosta³ zwrócony w sposób synchroniczny.
  To wyja¶nia tytu³ nadany tej podsekcji, poniewa¿ Parallel emuluje zachowanie synchronicznego zwracania wyniku.

  Zosta³o to osi±gniête poprzez wprowadzenie klasy uchwytu do wyniku, obudowuj±cej warto¶æ zwracan±, któr± nazwiemy warto¶ci± odroczon± (z ang. deferred value).
  Aby warto¶æ odroczona ¶ci¶le odpowiada³a typowi wynikowemu wyra¿enia, bêdzie ona szablonem typu parametryzowanym typem wynikowym wyra¿enia.
  Dziêki temu, ¿e znany by³ typ zwracany, mo¿liwe jest takie zaprojektowanie klasy warto¶ci odroczonej, ¿e przypomina w swoim zachowaniu typ wynikowy wyra¿enia.
  W momencie, gdy warto¶æ wyra¿enia bêdzie niezbêdna nast±pi wymuszenie ewaluacji, je¶li warto¶æ nie zosta³a jeszcze wyliczona, i pobranie wyniku.
  Przyk³adem takiej sytuacji jest przypisanie warto¶ci odroczonej na zmienn± o typie warto¶ci obudowywanej.
  Odbêdzie siê wtedy niejawna konwersja, do której bêdzie potrzebna rzeczywista warto¶æ wyra¿enia.
  
\subsubsection{Obs³uga sytuacji wyj±tkowych}
  Nale¿y równie¿ przyjrzeæ siê sytuacji, w której w czasie obliczania wyra¿enia wyst±pi b³±d, zasygnalizowany przez rzucenie wyj±tku.
  Biblioteka Parallel wspiera obs³ugê takiej sytuacji.
  Aby reakcja na takie zdarzenie by³a mo¿liwa wyj±tek musi zostaæ z³apany i zasygnalizowany programi¶cie.
  Przepuszczenie wyj±tku przez bibliotekê skutkowa³oby natychmiastowym b³êdnym zakoñczeniem programu, 
  gdy¿ programista nie mia³by ¿adnej mo¿liwo¶ci z³apania wyj±tku, poniewa¿ wyj±tek ten pochodzi³by z kodu biblioteki Parallel wykonywanym w innym w±tku.
  Biblioteka nie powinna t³umiæ ¿adnych wyj±tków, gdy¿ wtedy programista nie wiedzia³by co naprawdê dzieje siê w programie.
  
  Nasuwa siê zatem rozwi±zanie, w którym biblioteka wy³apuje wyj±tki wywo³ane w obliczanych wyra¿eniach i przekazuje je do w±tku g³ównego programu.
  Mo¿e to nast±piæ jedynie za po¶rednictwem warto¶ci odroczonej, poniewa¿ powrót z funkcji \feval nastêpuje przed rozpoczêciem obliczania wyra¿enia.
  Warto¶æ odroczona ma ustalony typ, wiêc pobranie warto¶ci nie mo¿e zwróciæ wyj±tku.
  Natomiast rozwi±zaniem, na które siê zdecydowano, jest ponowne rzucenie wyj±tku przy próbie pobrania warto¶ci lub wymuszenia jej wyliczenia.
  Programista u¿ywaj±cy Parallel powinien to mieæ na uwadze.

\subsection{Schemat interakcji kodu programu z bibliotek± Parallel}

  Dokonam podsumowania opisu idei biblioteki Parallel poprzez opisanie pokrótce tego jak kod aplikacji pisany przez programistê wspó³pracuje z kodem biblioteki Parallel.
  Schematycznie ilustruje to poni¿szy diagram.
\begin{figure}[h!]
 \includegraphics[width=\textwidth]{interaction.eps}
 \caption{Schemat interakcji z bibliotek± Parallel}
\end{figure}

  Schemat pokazuje jak w pierwszej kolejno¶ci kod programu wywo³uje funkcjê \feval, która s³u¿y do zlecenia obliczenia równoleg³ego wyra¿enia.
  Nastêpnie sterowanie przechodzi do cia³a funkcji \feval, czyli do kodu biblioteki Parallel.
  Funkcja \feval tworzy niezbêdne struktury danych oraz dodaje wyra¿enie \verb|exp| do wyra¿eñ czekaj±cych na wyliczenie.
  Potem nastêpuje powrót z funkcji \feval ze zwróceniem warto¶ci odroczonej \verb|d| i na jaki¶ czas kod programu i biblioteki Parallel zaprzestaj± komunikacji.
  Program wykonuje w³asne instrukcje, a biblioteka Parallel wykonuje w³asne, miêdzy innymi wyliczaj±c wyra¿enia, które zosta³y przekazane do wyliczenia równoleg³ego.
  Takie wyliczenie zachodzi w pewnym momencie równiez dla wyra¿enia \verb|exp|.
  
  Gdy potrzebna jest wyliczona warto¶æ wyra¿enia \verb|exp| nastêpuje automatycznie próba pobrania warto¶ci wyra¿enia z warto¶ci odroczonej \verb|d|.
  Wtedy sterowanie przechodzi do kodu biblioteki, który przekazuje z powrotem wyliczon± warto¶æ wyra¿enia \verb|exp|.
  Kod programu otrzymuje warto¶æ i mo¿e dalej prowadziæ swoje obliczenia.
  Tak wygl±da jeden cykl skorzystania z mechanizmu zlecania wyra¿eñ do równoleg³ego wyliczenia w bibliotece Parallel.
  
\clearpage
 
\input{other_models}

\newpage
\section{Zaawansowane przyk³ady u¿ycia biblioteki Parallel}

  Opis koncepcji biblioteki Parallel zakoñczê pokazaniem zaawansowanych przyk³adów wykorzystania biblioteki Parallel do prowadzenia równoleg³ych obliczeñ.
  W pierwszym z przyk³adów zaprezentujê, w jaki sposób biblioteka Parellel mo¿e s³u¿yæ do zrównoleglenia algorytmu szybkiego sortowania (z ang. quicksort).
  Drugi przyk³ad, wykorzystuj±cy w jeszcze wiêkszej mierze mo¿liwo¶ci biblioteki Parallel, poka¿e zdecydowan± przewagê biblioteki Parallel nad standardow± bibliotek± do obs³ugi w±tków Boost Thread.
  
\subsection{Równoleg³e szybkie sortowanie}

  Moja implementacja zrównoleglonego szybkiego sortowania opiera siê na prostej idei ``dziel i zwyciê¿aj''. 
  W ka¿dym rekurencyjnym wywo³aniu funkcji sortuj±cej na pocz±tku wywo³ywana jest funkcja \verb|partition|, 
  dziel±ca tablicê na czê¶ci o elementach mniejszych od pewnego wyró¿nionego elementu i o elementach wiêkszych od tego¿ elementu.
  Nastêpnie, je¶li podtablice do posortowania s± wystarczaj±co du¿e (w przyk³adzie limit zosta³ ustalony na 100 elementów), wywo³ywana jest rekurencyjnie funkcja sortuj±ca.
  W przeciwnym przypadku, tablica jest sortowana standardowym algorytmem sekwencyjnym szybkiego sortowania.
  
  W celu porównania biblioteki Parallel z ju¿ istniej±cym rozwi±zaniem, implementacje dostarczy³em w dwóch wersjach
  Jedna jest zaimplementowana przy u¿yciu biblioteki Boost Thread, a druga przy u¿yciu biblioteki Parallel.
  Oto implementacja wykorzystuj±ca standardow± bibliotekê do obs³ugi wielow±tkowo¶ci Boost Thread:
  \begin{lstlisting}
const unsigned limit = 100;
  
template <typename Item>
void thread_quicksort(Item array[], size_t l, size_t r)
{
  if (l < r)
  {
    size_t s = partition(array, l, r);
    boost::thread thread;
    if (s - l > limit) 
      thread = boost::thread(
	boost::bind(quicksort<int>, array, l, s - 1));
    else
      quicksort(array, l, s - 1);
    quicksort(array, s + 1, r);
    if (s - l > limit)
      thread.join();
  }
}
  \end{lstlisting}
  
  Jak mo¿na zauwa¿yæ, dla ka¿dego równoleg³ego wywo³ania funkcji \verb|thread_quicksort| musi zostaæ stworzony w±tek, poniewa¿ Boost Thread nie posiada puli w±tków.
  \footnote{Oczywi¶cie pulê w±tków mo¿na zaimplementowaæ wykorzystuj±c Boost Thread, ale moim celem by³o pokazanie przyk³adów zrównoleglenia szybkiego sortowania, 
  których napisanie by³o podobne pod wzglêdem struktury kodu i pracoch³onno¶ci.}
  W przypadu du¿ych tablic mo¿e to skutkowaæ spowolnieniem dzia³ania programu z powodu zbyt du¿ego obci±¿enia systemu w±tkami i zbyt czêstych prze³±czeñ kontekstu.
  
  Poni¿szy kod pokazuje implementacjê szybkiego sortowania, korzystaj±c± z biblioteki Parallel:
  \begin{lstlisting}
const unsigned limit = 100;
  
template <typename Item>
void parallel_quicksort(Item array[], size_t l, size_t r)
{
  if (l < r)
  {
    size_t s = partition(array, l, r);
    deferred_value<void> tmp;
    if (s - l > limit)
      tmp = parallel::eval(
	parallel::lazyf(quicksort<int>, array, l, s - 1));
    quicksort(array, s + 1, r);
    if (s - l > limit)
      tmp.force();
  }
}
  \end{lstlisting}
  
  Implementacja bazuj±ca na Parallel ma przewagê polegaj±c± na tym, ¿e w±tki s± tworzone tylko raz podczas inicjalizacji biblioteki Parallel.
  Zatem nie jest mo¿liwe przeci±¿enie systemu niekontrolowanym rozmno¿eniem siê w±tków.
  Poza istotn± korzy¶ci± zwi±zan± z brakiem potrzeby zarz±dzania w±tkami, w samej strukturze programu nie widaæ znacz±cych korzy¶ci z wyboru biblioteki Parallel.
  Kod wygl±da bardzo podobnie.
  Aby uwypukliæ zalety Parallel w porównaniu ze standardowymi bibliotekami bêdzie potrzebny kolejny przyk³ad.

\subsection{Równoleg³e sumowanie elementów tablicy}

  Przyk³ad zrównoleglenia sumowania elementów tablicy poka¿e jak wygodna jest sk³adnia bibioteki Parallel 
  w porównianiu ze sk³adni± biblioteki Boost.Threads, gdy równoleg³e obliczenia zwracaj± pewn± warto¶æ.
  
  Implementacja wielow±tkowa, napisana w oparciu o Boost.Threads, wygl±da nastêpuj±co:
  \begin{lstlisting}
void sum(int* wynik, int* begin, int* end)
{
  *wynik = 0;
  for (int* i = begin; i != end; i++) *wynik += *i;
}  

int array_sum_thread(int* array, size_t size)
{
  int s1, s2, s3, s4;
  boost::thread t1(
    boost::bind(sum, &s1, array, array + size/4));
  boost::thread t2(
    boost::bind(sum, &s2, array + size/4 + 1, array + size/2));
  boost::thread t3(
    boost::bind(sum, &s3, array + size/2 + 1, 3*size/4));
  boost::thread t4(
    boost::bind(sum, &s4, array + 3*size/4 + 1, array + size));
  t1.join();
  t2.join();
  t3.join();
  t4.join();
  return s1 + s2 + s3 + s4;
}
  \end{lstlisting}
  W tej implementacji niezbêdne by³o zdefiniowanie funkcji sumuj±cej pewien odcinek tablicy, która zwraca wynik przez jeden z argumentów,
  poniewa¿ w±tki nie potrafi± zwróciæ ¿adnych warto¶ci.
  Oczywi¶cie, w przypadku tak prostej implementacji nie ma mo¿liwo¶ci obs³ugi b³êdów, które mog± pojawiæ siê podczas obliczeñ.
  Ponadto programista musia³ zadbaæ o synchronizacjê w±tków, w tym przypadku poprzez wywo³anie funkcji \verb|join| na ka¿dym z w±tków,
  aby zagwarantowaæ, ¿e ka¿dy z nich zakoñczy³ siê przed zsumowaniem rezultatów podzadañ.
  
  Poni¿ej znajduje siê kod wykonuj±cy to samo zadanie, ale napisany przy pomocy biblioteki Parallel:
  \begin{lstlisting}
int sum(int* begin, int* end)
{
  int s = 0;
  for (int* i = begin; i != end; i++) s += *i;
  return s;
}
  
int array_sum_parallel(int* array, size_t size)
{
  deferred_value<in> sum = parallel::evaluate(
    *parallel::lazyf(sum, array, array + size/4));
  for (int i = 1; i < 4; i++)
  {
    sum += parallel::evaluate(parallel::lazyf(
      sum, array + (i * size)/4 + 1, array + ((i+1) * size)/4));
  }
  return sum;
}
  \end{lstlisting}
  W tym przyk³adzie, funkcja sumuj±ca tablicê ma bardziej naturaln± postaæ, w której wynik zwracany jest w standardowy sposób.
  W zwi±zku z tym, czêsto w praktycznych zastosowaniach bêdzie mo¿na u¿yæ ju¿ istniej±cej funkcji, co zmniejszy pracoch³onno¶æ pisania programów i u³atwi unikniêcie b³êdów.
  W kodzie programu nie widaæ ¿adnego ¶ladu jawnej synchronizacji pomiêdzy w±tkami, gdy¿ dziêki odpowiedniej implementacji warto¶ci odroczonych synchronizacja zarz±dzana jest automatycznie przez bibliotekê.
  Pomimo tego, ¿e w linii 13. przyk³adu warto¶æ sum jest u¿ywana, to prze³adowanie operatora \verb|+=| sprawia, ¿e obliczenie warto¶ci odroczonej nie jest wymuszane
  i wszystkie podzadania wykonuj± siê równocze¶nie.
  Dopiero w linii 15, gdzie warto¶æ odroczona \verb|sum| jest konwertowana do \verb|int| nastêpuje pobranie wyniku ze wszystkich zleconych obliczeñ i zwrócenie warto¶ci.
  Warto równie¿ zauwa¿yæ, ¿e kod napisany przy pomocy biblioteki Parallel jest bardziej czytelny i krótszy.
 