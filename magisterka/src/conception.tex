
\chapter{Koncepcja biblioteki}\label{r:koncepcja}

  W tym rozdziale zostan± przedstawione g³ówne za³o¿enia oraz szkic projektu biblioteki Parallel. 
  Ponadto biblioteka Parallel zostanie zestawiona z istniej±cymi bibliotekami do programowania równoleg³ego w celu pokazania ró¿nic i uzasadnienia potrzeby stworzenia nowej biblioteki.

\section{Cele biblioteki}

  Tworzeniu biblioteki Parallel przy¶wieca³y jasno sprecyzowane cele, których ide± przewodni± by³o u³atwienie wykorzystywania obliczeñ równoleg³ych w programach.
  Wymienionym poni¿ej celom by³o podporz±dkowane projektowanie API i implementacja biblioteki.

\subsection{Wysoka efektywno¶æ}

  Jednym z g³ównych powodów stosowania zrównoleglania obliczeñ jest przyspieszanie ich wykonania. Dlatego sama biblioteka do zrównoleglania powinna dzia³aæ szybko.
  Niedopuszczaln± by³aby sytuacja, gdyby program wspó³bie¿ny wykonywa³ siê wolniej ni¿ jego sekwencyjny odpowiednik.
  Biblioteka Parallel bêdzie bibliotek± ogólnego zastosowania, przy pomocy, które bêdzie mo¿liwe prowadzenie dowolnych obliczeñ.
  W zwi±zu z tym, nie ma mo¿liwo¶ci zoptymalizowania biblioteki pod k±tem prowadzenia jednego z góry znanego typu obliczeñ.
  Dlatego, oprócz szybkiego dzia³ania mechanizmów wbudowanych w bibliotekê, niezbêdne jest pozwolenie programi¶cie na podejmowanie decyzji o takim prowadzeniu obliczeñ, 
  ¿e ich wykonanie przy u¿yciu biblioteki Parallel bêdzie efektywne.
  Kluczow± rolê odgrywa odpowiedni podzia³ zadañ przez programistê (granularno¶æ obliczeñ).
  
\subsection{Zwiêkszenie produktywno¶ci programisty}
  Problem z efektywno¶ci± programisty w przypadku pisania programów równoleg³ych polega na tym, ¿e takie programy s± trude do pisania, st±d wymagaj± znacznych nak³adów pracy programistów.
  Zrównoleglenie choæby niewielkiego fragmentu programu wymaga znacznie wiêcej czasu ni¿ napisanie jego sekwencyjnego odpowiednika.
  Byæ mo¿e dlatego obliczenia równoleg³e wykorzystywane s± wy³±cznie wtedy, gdy ju¿ nie ma innego sposobu osi±gniêcia niezbêdnego minimum wydajno¶ci programu.
  Biblioteka Parallel celuje w zmianê tego stanu rzeczy, dziêki wprowadzeniu modelu programowania równoleg³ego, który bêdzie tak intuicyjny jak programowanie sekwencyjne.
  Dziêki czemu napisanie kodu, który dzia³a wspó³bie¿nie, bêdzie prawie tak samo szybkie jak kodu sekwencyjnego, co pozwoli³oby uzyskaæ programistom szybsze programy przy zbli¿onej produktywno¶ci ich pracy.

\subsection{Czytelno¶æ kodu}

  Tym, co najbardziej utrudnia zrozumienie programów wspó³bie¿nych jest konieczno¶æ zrozumienia zale¿no¶ci pomiêdzy odrêbnymi równolegle dzia³aj±cymi czê¶ciami programu.
  Zazwyczaj te zale¿no¶æi dotycz± miejsc w kodzie, które s± od siebie stosunkowo odleg³e.
  Mnogo¶æ niejawnych zale¿no¶ci i przeplotów wykonañ programu sprawiaj±, ¿e nawet pozornie proste operacje s± trudne do poprawnego zaprogramowania, a przyczyny ewentualnych b³êdów s± bardzo trudne do zidentyfikowania.
  Jednym z bardziej wymownych przyk³adów popieraj±cych to stwierdzenie jest problem implementacji semafora uogólnionego przy pomocy semaforów binarnych \cite{gensem}, 
  gdzie b³êdne rozwi±zania pojawia³y siê w publikacjach naukowych i nawet przez kilka lat by³y uwa¿ane za poprawne.
  St±d celem, który zosta³ postawiony przed bibliotek± Parallel by³o stworzenie takiego modelu obliczeñ, w którym obliczenia równoleg³e prowadzone by³yby w sposób czytelny.
  Oznacza to, i¿ miejsca wykorzystania równoleg³o¶ci powinny byæ wyra¼nie widoczne i ³atwe do odnalezienia, a sam zapis nie powinnien komplikowaæ kodu.
  Najwa¿niejsze jest to, ¿e struktura programu napisanego przy pomocy biblioteki Parallel nie powinna istotnie ró¿niæ siê od struktury programu sekwencyjnego.
  Pozwoli to na uzyskanie kodu, który bêdzie znacznie ³atwiej zrozumieæ.

\subsection{Transparencja}

  Biblioteka Parallel powinna udostêpniaæ programi¶cie wgl±d w to, w jaki sposób oblczenia równoleg³e bêd± prowadzone.
  Dziêki temu programista bêdzie móg³ uwzglêdniæ podczas programowania specyfikê biblioteki.
  Miêdzy innymi bêdzie móg³ dostosowaæ wielko¶æ zlecanych fragmentów obliczeñ (ziarnisto¶æ obliczeñ), tak aby zmaksymalizowaæ wydajno¶æ programu.
  
\subsection{Abstrakcja}

  Abstrakcja ukrywa niepotrzebne szczegó³y implementacji przed programist±, co pozwala na zwiêkszenie jego produktywno¶ci.
  Biblioteka powinna ofertowaæ proste ogólne API, tak aby programista móg³, po zapoznaniu siê z funkcjami oferowanymi przez bibliotekê, w krótkim czasie przyst±piæ do korzystania z Parallel.

\subsection{Ograniczenie konieczno¶ci korzystania z mechanizmów komunikacji i synchronizacji procesów równoleg³ych}

  Projektowawnie komunikacji i synchronizacji w programach wspó³bie¿nych jest czym¶, co decyduje o fakcie, ¿e programowanie równoleg³e jest tak trudnym zadaniem.
  Celem biblioteki Parallel jest zdjêcie w znacznym stopniu tego obci±¿enia z programisty.
  Komunikacja pomiêdzy ró¿nymi w±tkami wykonania bêdzie koordynowana przez bibliotekê.
  Biblioteka nie mo¿e wyrêczyæ jednak programisty we wszystkim, ochrona spójno¶ci struktur danych programu pozostanie w rêkach programisty.
  
\subsection{Przenaszalno¶æ}
  
  Jest to bardzo istotna cecha biblioteki, dziêki której kod pisany przy u¿yciu biblioteki Parallel bêdzie móg³ byæ kompilowany i wykonywany na dowolnych platformach.
  Zostanie to osi±gniête dziêki zaprogramowaniu biblioteki w pe³nej zgodno¶ci z przysz³ym standardem jêzyka C++ (standard C++0x).
  U¿ycie nowego standardu jest niezbêdne ze wzglêdu na zaawansowane konstrukcje jêzykowe potrzebne do zaprogramowania biblioteki Parallel.
  Konsekwencj± tego bêdzie niezgodno¶æ biblioteki z wcze¶niejszymi standardami jêzyka C++, ale umo¿liwi stworzenie lepszego, bardziej czytelnego kodu biblioteki przy u¿yciu nowoczesnych technik programowania w C++.


\section{Prezentacja idei biblioteki Parallel}

  Niniejsza sekcja przedstawia inspiracjê oraz wynik koñcowy pracy koncepcyjnej nad bibliotek±.
  Zostan± zarysowane wysokopoziomowa architektura biblioteki oraz funkcjonowanie biblioteki z punktu widzenia programisty-u¿ytkownika.

\subsection{Inspiracja}

  Powstanie biblioteki zosta³o zainspirowane bibliotek± do prowadzenia obliczeñ równoleg³ych w jêzyku Haskell, Parallel Haskell\cite{parhas}.
  Ta biblioteka pozwala w sposób bardzo intuicyjny obliczaæ dwa wyra¿enia równolegle.
  Oto przyk³ad funkcji obliczaj±cej w sposób równoleg³y n-t± liczbê Fibonacciego:
  \begin{lstlisting}[language=Haskell]
    import Control.Parallel

    nfib :: Int -> Int
    nfib n | n <= 1 = 1
       | otherwise = par n1 (seq n2 (n1 + n2))
                     where n1 = nfib (n-1)
                           n2 = nfib (n-2)
  \end{lstlisting}
  
  Analogiczny program sekwencyjny wygl±da³by nastêpuj±co:
  \begin{lstlisting}[language=Haskell]
    import Control.Parallel

    nfib :: Int -> Int
    nfib n | n <= 1 = 1
       | otherwise = (n1 + n2)
                     where n1 = nfib (n-1)
                           n2 = nfib (n-2)
  \end{lstlisting}
  
  W Haskellu funkcja \verb|par| wskazuje, ¿e wyliczenie dwóch wyra¿eñ mo¿e odbyæ siê równolegle i w czasie wykonania podejmowana jest decyzja o sposobie wyliczenia.
  Obliczenia odbywaj± siê równolegle, gdy jest to bardziej efektywne od wykonania sekwencyjnego.
  Ta konstrukcja pokazuje z jak zadziwiaj±c± prostot± mo¿na pisaæ programy równoleg³e.
  W Haskellu wystarczy dodaæ jedno s³owo, aby oznaczyæ wyra¿enie jako przeznaczone do zrównoleglenia.
  Taka by³a pierwotna inspiracja dla zbudowania biblioteki Parallel.
  Przekazanie wyra¿enia do odpowiedniej funkcji powinno poskutkowaæ jego zrównolegleniem.
  
\subsection{Zlecanie obliczeñ}\label{ss:zlecanie}

  Zlecanie równoleg³ego wykonania obliczeñ powinno jak najmniej ingerowaæ w sekwencyjny kod programu dla zachowania jego intuicyjno¶ci.
  (Dla wyja¶nienia dodam, ¿e nie twierdzê, i¿ jedynie sekwencyjny kod programu mo¿e byæ intuicyjny, jednak praktyka pokazuje, ¿e zrozumienie programu, 
  który zosta³ zapisany jako kilka jednocze¶nie wykonywanych ci±gów instrukcji jest znacznie trudniejsze od zrozumienia programu sekwencyjnego.)
  Do oznaczenia wyra¿enia, które ma zostaæ wykonane równolegle bêdzie s³u¿y³a funkcja \verb|eval|, przyjmuj±ca jako argument wyra¿enie do wykonania.
  Obliczenie przekazanego wyra¿enia odbêdzie siê równolegle.
  
  Sk³adnia wyra¿eñ powinna byæ jak najbardziej zbli¿ona do sk³adni jêzyka C++, bo to by konstruowanie wyra¿eñ by³o ³atwe dla programisty.
  Idealnie by³oby, gdyby programista móg³ przekazaæ wyra¿enie w jego standardowej postaci w jêzyku C++, czyli w nastêpuj±cy sposób:
  \begin{lstlisting}[numbers=none, frame=none]
    parallel::eval(fibonacci_od(40));
  \end{lstlisting}
  W tej chwili czytelnik dobrze zaznajomiony z semantyk± jêzyka C++ móg³ dostrzec pewien problem do pokonania zwi±zany z przekazaniem wyra¿enia do wykonania.
  W podanym przyk³adzie takie wyra¿enie najpierw zosta³oby wyliczone, poniewa¿ jêzyk C++ posiada gorliw± semantykê wyliczania wyra¿eñ, a dopiero nastêpnie by³oby przekazane do funkcji \verb|eval|.
  Zatem funkcja eval otrzyma³aby gotowy wynik i ¿adne równoleg³e obliczenia nie by³yby ju¿ potrzebne.
  Takiej sytuacji nale¿y unikn±æ poprzez zaprojektowanie specjalnego sposobu przekazywania wyra¿eñ do funkcji \feval.
  Zabieg, który nale¿y zastosowaæ nazywa siê uleniwieniem wyra¿enia i polega na odroczeniu obliczenia warto¶ci wyra¿enia do momentu, gdy ta warto¶æ bêdzie potrzebna.
  Wyra¿enie leniwe nie jest wyliczane w miejscu pojawienia siê.
  Dziêki zastosowaniu takiem metody wyra¿enie, które ma byæ wyliczone równolegle pojawia siê w kodzie tam, gdzie jest to najwygodniejsze, w jawnej postaci, a potem mo¿e zostaæ przekazane od mechanizmu ewaluacji biblioteki Parallel.
  
\subsubsection{Leniwe wyra¿enia w jêzyku C++}

  Stworzenie leniwego wyra¿enia w jêzyku C++ nie wydaje siê prostym zadaniem.
  Domy¶la semantyka obliczeñ jest gorliwa, nie ma s³ów kluczowych pozwalaj±cych na dodanie leniwo¶ci, C++ nie pozwala równie¿ na rozszerzenie sk³adni jêzyka.
  Wskazówka do rozwiazanie problemu leniwych wyra¿eñ w jêzyku C++ znajduje siê w ksi±¿ce \textit{More C++ Idioms}\cite{idioms}, która przedstawia idiom C++ szablonu wyra¿enia (z ang. Expression Template).
  Idea stworzenia szablonu wyra¿enia polega na reprezentacji wyra¿enia przez zbudowanie odpowiedniego drzewa typów, które jest Abstrakcyjnym Drzewem Syntaktycznym (z ang. Abstract Syntax Tree - AST) wyra¿enia.
  Dok³adny opis zastosowanej metody znajduje siê w rozdziale po¶wiêconym implementacji biblioteki.
  
  \subsubsection{Funkcja \texttt{eval}}\label{sss:eval}

  Jeszcze s³owo w rozdziale przedstawiaj±cym koncepcje biblioteki nale¿y siê funkcji \feval, która jest g³ówn± funkcj± z API dostêpnego dla programisty.
  Funkcja s³u¿y do zlecenia wykonania obliczeñ równoleglych.
  W ciele funkcji znajduje siê przekazanie wyra¿enia w formie leniwej do mechanizmu ewaluacyjnego.
  Warto¶æ zwracana przez funkcjê powinna udostêpniaæ mo¿liwo¶æ sprawdzenia wyniku obliczenia.
  Przekazywanie wyników obliczeñ przez bibliotekê Parallel zosta³o omówione w sekcji \nameref{s:koncepcja_wynik}.
  
\subsection{Wykonanie zadañ}\label{ss:wykonywanie}

  W tej podsekcji zostanie omówiony mechanizm wyliczania wyra¿eñ w bibliotece Parallel po przekazaniu ich do funkcji \texttt{eval}.
  Jest to serce biblioteki, dziêki któremu biblioteka potrafi pe³niæ swoje funkcje.
  
  \subsubsection{Dzia³anie mechanizmu ewaluacji}
  
  Ewaluacja wyra¿eñ przekazanych do obliczenia bêdzie odbywa³a siê zgodnie z wzorcem producent-konsument.
  Producentem wyra¿eñ bêdzie kod programu korzystaj±cego z biblioteki Parallel i przekazuj±cy wyra¿enia przy pomocy funkcji \texttt{eval}.
  Natomiast konsumentem bêd± w±tki-pracownicy biblioteki Parallel, których jedynym zadaniem bêdzie oczekiwanie na zadania (wyra¿enia do ewaluacji) i ich wykonywanie.
  Ze wzglêdu na efektywno¶æ wykorzystany zostanie wzorzec puli w±tków (thread pool opisany w \cite{threadpool}).
  Zatem w±tek nie bêdzie tworzony dla wykonania ka¿dego zadania, a bêdzie istnia³a grupa w±tków dedykowanych do wykonywania obliczeñ, która bêdzie zaalokowana w programie tak d³ugo jak program bêdzie korzysta³ z biblioteki Parallel.
  O liczbie w±tków bêdzie decydowa³ u¿ytkownik, gdy¿ ich liczba mo¿e mieæ znacz±cy wp³yw na wydajno¶æ programu, a nie istnieje optymalna liczba w±tków dla ka¿dego rodzaju zastosowania biblioteki Parallel.
  Standardowo w tym modelu wyra¿enia bêd± trafia³y do kolejki zadañ, w której bêd± oczekiwa³y na wyliczenie.
  
  Mo¿e siê zdarzyæ, ¿e wyra¿enie nie zostanie wyliczone do momentu gdy bêdzie potrzebne w programie, który przekaza³ je do obliczenia.
  W tej sytuacji biblioteka Parallel reaguje w takie sposób, by nie blokowaæ programu bez przyczyny.
  Program dotar³by do takiego miejsca, ¿e potrzebuje wyliczonego wyra¿enia przekazanego do Parallel, a nie zosta³o jeszcze wykonane, program musia³by oczekiwaæ na wykonanie obliczeñ.
  Skoro program nie ma nic innego do wykonania to w±tek programu sam mo¿e wyliczyæ wyra¿enie, odpowiednio informuj±c bibliotekê Parallel, aby wyra¿enie nie zosta³o wykonane kilkakrotnie, 
  gdy¿ nierozs±dne by³oby narzucanie ograniczenia nakazuj±cego, ¿eby wyra¿enia przekazywane do biblioteki Parallel by³y idempotentne.
  Ca³o¶ci± procesu alternatywnego wyliczania obliczenia przez w±tek programu powinna zarz±dzaæ biblioteka, tak aby nie by³o to zauwa¿alne dla programisty.
  
  Jednym z rozszerzeñ mechanizmu ewaluacji mog³oby byæ dodanie automatycznego dostosowywania liczby w±tków w puli do intensywno¶ci prowadzonych obliczeñ.
  W pierwszej wersji biblioteki nie przewidziano w projekcie takiej funkcjonalno¶ci.
  
  W bibliotece nie wystêpuje problem balansowania obci±¿enia ró¿nych w±tków, gdy¿ wszystkie w±tki nale¿±ce do puli s± identycznie i dziêki wykorzystaniu wspólnej kolejki zadañ, obci±¿enie jest równowa¿one samoczynnie.
  W±tek koñcz±c pracê nad jednym zadaniem siêga do kolejki po nastêpne.
  
\subsubsection{Mechanizmy synchronizacji}

  Dla poprawno¶ci dzia³ania biblioteki niezbêdne by³o zaimplementowanie mechanizmów synchronizacji w±tków-pracowników oraz kodu programu. 
  Zosta³y one opisane w sekcji \nameref{s:ewaluacja}.
  U¿ywaj±c biblioteki Parallel programista nie musi martwiæ siê o synchronizacjê dzia³ania biblioteki Parallel.
  
  Biblioteka nie mo¿e jednak przewidzieæ zale¿no¶ci w kodzie programu, dlatego ochrona danych, na których dokonywane s± obliczenia pozostaje w rêkach programisty.
  Parallel nie narzuca ¿adnych ograniczeñ, co do korzystania w kodzie zrównoleglanych wyra¿eñ instrukcji dostêpu do struktur danych, z których korzysta wiele w±tków jednoczesnie.
  W tej sytuacji programista musi zadbaæ o odpowiednie umieszczenie sekcji krytycznych w kodzie obliczanych wyra¿eñ, tak aby program by³ bezpieczny i ¿ywotny.
  
\subsection{Sposób przekazywania wyniku}\label{s:koncepcja_wynik}

  Kod korzystaj±cy z biblioteki Parallel powinien wygl±daæ naturalnie.
  Skoro do funkcji \texttt{eval} przekazujemy wyra¿enie, to naturalnym oczekiwaniem jest to, ¿e w wyniku ewaluacji otrzymamy warto¶æ tego wyra¿enia.
  Problem le¿y w tym, ¿e w momencie powrotu z funkcji \texttt{eval} bêdzie znany jedynie typ wyra¿enia, a nie jego warto¶æ.
  Warto¶æ zostanie obliczona pó¼niej przez mechanizm ewaluacji biblioteki Parallel.
  Wynika st±d potrzeba wprowadzenie klasy obudowuj±cej warto¶æ zwracan±, uchwytu do wyniku, nazwijmy go warto¶ci± odroczon± (z ang. deferred value).
  Aby warto¶æ odroczona ¶ci¶le odpowiada³a typowi wynikowemu wyra¿enia, bêdzie ona szablonem typu parametryzowanym typem wynikowym wyra¿enia.
  Dziêki temu, ¿e znany by³ typ zwracany, mo¿liwe jest takie zaprojektowanie klasy warto¶ci odroczonej, ¿e przypomina w swoim zachowaniu typ wynikowy wyra¿enia.
  
  Warto¶ci odroczonej mo¿na u¿ywaæ prawie zamiennie z typem, który obudowuje.
  To dziêki temu, ¿e jest dostêpna niejawna konwersja do obudowywanego typu, a zastosowanie operatorów bêdzie dawa³o identyczny wynik.
  W momencie, gdy warto¶æ wyra¿enia bêdzie niezbêdna nast±pi wymuszenie ewaluacji, je¶li warto¶æ nie zosta³a jeszcze wyliczona, i pobranie wyniku.
  Przyk³adem takiej sytuacji jest przypisanie warto¶ci odroczonej na zmienn± o typie warto¶ci obudowywanej.
  Odbêdzie siê wtedy niejawna konwersja, do której bêdzie potrzebna rzeczywista warto¶æ wyra¿enia.
  
\subsubsection{Obs³uga sytuacji wyj±tkowych}
  Nale¿y równie¿ przyjrzeæ siê sytuacji, w której w czasie obliczania wyra¿enia wyst±pi b³±d, zasygnalizowany przez rzucenie wyj±tku.
  Biblioteka Parallel powinna wspieraæ obs³ugê takiej sytuacji w kodzie.
  Aby reakcja ze strony programisty by³a mo¿liwa wyj±tek musi zostaæ z³apany i zasygnalizowany programi¶cie.
  Przepuszczenie wyj±tku przez bibliotekê skutkowa³oby natychmiastowym b³êdnym zakoñczeniem programu, 
  gdy¿ programista nie mia³by ¿adnej mo¿liwo¶ci z³apania wyj±tku, gdy¿ wyj±tek ten pochodzi³by z kodu biblioteki Parallel wykonywanym w innym w±tku.
  Biblioteka nie powinna równie¿ t³umiæ wszystkich wyj±tków, gdy¿ programista nie wiedzia³by wtedy co siê dzieje w programie, a warto¶æ przypisana na warto¶æ odroczon± by³aby niezdefinowana.
  
  Nasuwa siê zatem rozwi±zanie, w którym biblioteka wy³apywa³aby wyj±tki wywo³ane w obliczanych wyra¿eniach, ale przekazywane by³yby one do w±tku g³ównego programu.
  Mo¿e to nast±piæ jedynie za po¶rednictwem warto¶ci odroczonej, poniewa¿ powrót z funkcji \feval nastêpuje zazwyczaj przed rozpoczêciem obliczania wyra¿enia.
  Warto¶æ odroczona ma ustalony typ, wiêc warto¶æ odroczona nie mo¿e zwróciæ wyj±tku.
  Jednak¿e, to co mo¿e zostaæ wykonane to ponowne rzucenie wy³apanego i przekazanego do warto¶ci odroczonej wyj±tku przy próbie pobrania wyliczonej warto¶ci.
  Wtedy wyj±tek powsta³y w obliczeniach by³by przekazywany do kodu g³ównego w±tku i programista mia³by mo¿liwo¶æ jego obs³ugi w dobrze zdefinowanym miejscu.
  
% \subsubsection{Metody klasy reprezentuj±cej uchwyt do wyniku}
% 
%   Interfejs publiczny klasy reprezentuj±cej uchwyt do wyniku bêdzie zawiera³ metody:
% \begin{itemize}
%  \item pobrania warto¶ci,
%  \item sprawdzenia czy warto¶æ zosta³a ju¿ wyliczona,
%  \item operator konwersji do typu wyniku wyra¿enia
% \end{itemize}
% 
% \paragraph{Operatory}~\\
%   Ponadto w interfejsie klasy obudowuj±cej wynik bêd± znajdowa³y siê wszystkie operatory, które maj± sens dla typu obudowywanego.
%   Oczywi¶cie ze wzglêdu na  ograniczenia jêzyka niemo¿liwe jest zdefinowanie operatorów, których prze³adowywanie jest zabronione, takich jak \verb|.| oraz \verb|.*|.
%   
%   Mo¿liwa jest taka sytuacja, w której wykorzystanie warto¶ci odroczonej w wyra¿eniu nie bêdzie wymusza³o natychmiastowego wyliczenia warto¶ci odroczonej.
%   We¼my jako przyk³ad nastepuj±c± instrukcjê:
% \begin{verbatim}
%   auto c = odroczony_int + 42;
% \end{verbatim}
%   Czy musimy znaæ warto¶æ odroczony\_int, aby przypisaæ odpowiedni± warto¶æ na zmienn± c?
%   To zale¿y w tym przypadku od implementacji operatora \verb|+|.
%   Je¶li operator dodawania bêdzie tak zaprojektowany, ¿e dodanie warto¶ci odroczonej sparametryzowanej typem int oraz liczby ca³kowitej zwraca inta, to oczywi¶cie warto¶æ odroczona musi byæ znana.
%   Natomiast dziêki temu, ¿e przytoczona w przyk³adzie instrukcja zawiera pewn± dowolno¶æ w postaci automatycznego typowania zmiennej c, to nic nie stoi na przeszkodzie, ¿eby c by³o równie¿ warto¶ci± odroczon±.
%   I taka decyzja projektowa zosta³a podjêta w bibliotece Parallel.
%   Operatory bêd± zwracaæ warto¶æ typu warto¶æ odroczona, aby prowadziæ obliczenia w taki sposób, ¿e wymuszenie obliczenia warto¶ci odroczonej by³o od³o¿one najpó¼niej jak to mo¿liwe.
%   Warto¶æ odroczna zwracana przez operatory, bêdzie zawiera³a leniwe wyra¿enie podobne do tego, które jest przekazywane funkcji \verb|eval|.
%   W momencie wymuszenia wyliczenia takiej warto¶ci odroczonej to leniwe wyra¿enie zostanie wyliczone.
%   Pozwoli to na lepsze zrównoleglenie obliczeñ, poniewa¿ umo¿liwie przeprowadzenie wiêkszej liczby obliczeñ przez w±tki-pracowników z biblioteki Parallel.
%   
%\subsubsection{Wp³yw sposobu przekazywania wyniku na cele biblioteki Parallel}

\subsection{Schemat interakcji kodu programu z bibliotek± Parallel}

  Podsumowania opisu idei biblioteki Parallel dokonam poprzez opisanie pokrótce tego jak kod aplikacji pisany przez programistê wspó³pracuje z kodem biblioteki Parallel.
  Schematycznie ilustruje to poni¿szy diagram.
\begin{figure}[h!]
 \includegraphics[width=\textwidth]{interaction.eps}
 \caption{Schemat interakcji z bibliotek± Parallel}
\end{figure}

  Schemat pokazuje jak w pierwszej kolejno¶ci kod programu wywo³uje funkcjê \feval, która s³u¿y do zlecenia obliczenia równoleg³ego wyra¿enia.
  Nastêpnie sterowanie przechodzi do cia³a funkcji \feval, czyli do kodu biblioteki Parallel.
  Funkca \feval tworzy niezbêdne struktury danych oraz dodaje wyra¿enie \verb|exp| do wyra¿eñ czekaj±cych na wyliczenie.
  Potem nastêpuje powrót z funkcji \feval ze zwróceniem warto¶ci odroczonej \verb|d| i na jaki¶ czas kod programu i biblioteki Parallel zaprzestaj± komunikacji.
  Kod programu wykonuje w³asne instrukcje, a kod Parallel wykonuje w³asne zadania, miêdzy innymi wyliczaj±c wyra¿enia, które zosta³y wskazane do wyliczenia równoleg³ego.
  Takie wyliczenie zachodzi w pewnym momencie w czasie równiez dla wyra¿enia \verb|exp|.
  
  Gdy nadchodzi moment w kodzie programu, gdy potrzebna jest wyliczona warto¶æ wyra¿enia to nastêpuje automatycznie próba pobrania warto¶ci wyra¿enia z warto¶ci odroczonej \verb|d|.
  Wtedy nastêpuje przekazanie sterowania do kodu biblioteki, który przekazuje z powrotem wyliczon± warto¶æ wyra¿enia \verb|exp|.
  Kod programu otrzymuje warto¶æ i mo¿e dalej prowadziæ swoje obliczenia.
  Tak wygl±da jeden cykl skorzystania z mechanizmu zlecania wyra¿eñ do równoleg³ego wyliczenia w bibliotece Parallel.
  