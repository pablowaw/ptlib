
\chapter{Koncepcja biblioteki}\label{r:koncepcja}

  W tym rozdziale zostan± przedstawione g³ówne za³o¿enia oraz szkic projektu biblioteki Parallel. 
  Ponadto biblioteka Parallel zostanie zestawiona z istniej±cymi bibliotekami do programowania równoleg³ego w celu pokazania ró¿nic i uzasadnienia potrzeby stworzenia nowej biblioteki.

\section{Cele biblioteki}\label{s:cele}

  Tworzeniu biblioteki Parallel przy¶wieca³y jasno sprecyzowane cele, których ide± przewodni± by³o u³atwienie wykorzystywania obliczeñ równoleg³ych w programach.
  Wymienionym poni¿ej celom by³o podporz±dkowane projektowanie API i implementacja biblioteki.

\subsection{Wysoka efektywno¶æ}

  Jednym z g³ównych powodów stosowania zrównoleglania obliczeñ jest przyspieszanie ich wykonania. Dlatego sama biblioteka do zrównoleglania powinna dzia³aæ szybko.
  Niedopuszczaln± by³aby sytuacja, gdyby program wspó³bie¿ny wykonywa³ siê wolniej ni¿ jego sekwencyjny odpowiednik.
  Biblioteka Parallel bêdzie bibliotek± ogólnego zastosowania, przy pomocy, które bêdzie mo¿liwe prowadzenie dowolnych obliczeñ.
  W zwi±zu z tym, nie ma mo¿liwo¶ci zoptymalizowania biblioteki pod k±tem prowadzenia jednego z góry znanego typu obliczeñ.
  Dlatego, oprócz szybkiego dzia³ania mechanizmów wbudowanych w bibliotekê, niezbêdne jest pozwolenie programi¶cie na podejmowanie decyzji o takim prowadzeniu obliczeñ, 
  ¿e ich wykonanie przy u¿yciu biblioteki Parallel bêdzie efektywne.
  Kluczow± rolê odgrywa odpowiedni podzia³ zadañ przez programistê (granularno¶æ obliczeñ).
  
\subsection{Zwiêkszenie produktywno¶ci programisty}
  Problem z efektywno¶ci± programisty w przypadku pisania programów równoleg³ych polega na tym, ¿e takie programy s± trude do pisania, st±d wymagaj± znacznych nak³adów pracy programistów.
  Zrównoleglenie choæby niewielkiego fragmentu programu wymaga znacznie wiêcej czasu ni¿ napisanie jego sekwencyjnego odpowiednika.
  Byæ mo¿e dlatego obliczenia równoleg³e wykorzystywane s± wy³±cznie wtedy, gdy ju¿ nie ma innego sposobu osi±gniêcia niezbêdnego minimum wydajno¶ci programu.
  Biblioteka Parallel celuje w zmianê tego stanu rzeczy, dziêki wprowadzeniu modelu programowania równoleg³ego, który bêdzie tak intuicyjny jak programowanie sekwencyjne.
  Dziêki czemu napisanie kodu, który dzia³a wspó³bie¿nie, bêdzie prawie tak samo szybkie jak kodu sekwencyjnego, co pozwoli³oby uzyskaæ programistom szybsze programy przy zbli¿onej produktywno¶ci ich pracy.

\subsection{Czytelno¶æ kodu}

  Tym, co najbardziej utrudnia zrozumienie programów wspó³bie¿nych jest konieczno¶æ zrozumienia zale¿no¶ci pomiêdzy odrêbnymi równolegle dzia³aj±cymi czê¶ciami programu.
  Zazwyczaj te zale¿no¶æi dotycz± miejsc w kodzie, które s± od siebie stosunkowo odleg³e.
  Mnogo¶æ niejawnych zale¿no¶ci i przeplotów wykonañ programu sprawiaj±, ¿e nawet pozornie proste operacje s± trudne do poprawnego zaprogramowania, a przyczyny ewentualnych b³êdów s± bardzo trudne do zidentyfikowania.
  Jednym z bardziej wymownych przyk³adów popieraj±cych to stwierdzenie jest problem implementacji semafora uogólnionego przy pomocy semaforów binarnych \cite{gensem}, 
  gdzie b³êdne rozwi±zania pojawia³y siê w publikacjach naukowych i nawet przez kilka lat by³y uwa¿ane za poprawne.
  St±d celem, który zosta³ postawiony przed bibliotek± Parallel by³o stworzenie takiego modelu obliczeñ, w którym obliczenia równoleg³e prowadzone by³yby w sposób czytelny.
  Oznacza to, i¿ miejsca wykorzystania równoleg³o¶ci powinny byæ wyra¼nie widoczne i ³atwe do odnalezienia, a sam zapis nie powinnien komplikowaæ kodu.
  Najwa¿niejsze jest to, ¿e struktura programu napisanego przy pomocy biblioteki Parallel nie powinna istotnie ró¿niæ siê od struktury programu sekwencyjnego.
  Pozwoli to na uzyskanie kodu, który bêdzie znacznie ³atwiej zrozumieæ.

\subsection{Transparencja}

  Biblioteka Parallel powinna udostêpniaæ programi¶cie wgl±d w to, w jaki sposób oblczenia równoleg³e bêd± prowadzone.
  Dziêki temu programista bêdzie móg³ uwzglêdniæ podczas programowania specyfikê biblioteki.
  Miêdzy innymi bêdzie móg³ dostosowaæ wielko¶æ zlecanych fragmentów obliczeñ (ziarnisto¶æ obliczeñ), tak aby zmaksymalizowaæ wydajno¶æ programu.
  
\subsection{Abstrakcja}

  Abstrakcja ukrywa niepotrzebne szczegó³y implementacji przed programist±, co pozwala na zwiêkszenie jego produktywno¶ci.
  Biblioteka powinna ofertowaæ proste ogólne API, tak aby programista móg³, po zapoznaniu siê z funkcjami oferowanymi przez bibliotekê, w krótkim czasie przyst±piæ do korzystania z Parallel.

\subsection{Ograniczenie konieczno¶ci korzystania z mechanizmów komunikacji i synchronizacji procesów równoleg³ych}

  Projektowawnie komunikacji i synchronizacji w programach wspó³bie¿nych jest czym¶, co decyduje o fakcie, ¿e programowanie równoleg³e jest tak trudnym zadaniem.
  Celem biblioteki Parallel jest zdjêcie w znacznym stopniu tego obci±¿enia z programisty.
  Komunikacja pomiêdzy ró¿nymi w±tkami wykonania bêdzie koordynowana przez bibliotekê.
  Biblioteka nie mo¿e wyrêczyæ jednak programisty we wszystkim, ochrona spójno¶ci struktur danych programu pozostanie w rêkach programisty.
  
\subsection{Przenaszalno¶æ}
  
  Jest to bardzo istotna cecha biblioteki, dziêki której kod pisany przy u¿yciu biblioteki Parallel bêdzie móg³ byæ kompilowany i wykonywany na dowolnych platformach.
  Zostanie to osi±gniête dziêki zaprogramowaniu biblioteki w pe³nej zgodno¶ci z przysz³ym standardem jêzyka C++ (standard C++0x).
  U¿ycie nowego standardu jest niezbêdne ze wzglêdu na zaawansowane konstrukcje jêzykowe potrzebne do zaprogramowania biblioteki Parallel.
  Konsekwencj± tego bêdzie niezgodno¶æ biblioteki z wcze¶niejszymi standardami jêzyka C++, ale umo¿liwi stworzenie lepszego, bardziej czytelnego kodu biblioteki przy u¿yciu nowoczesnych technik programowania w C++.


\section{Prezentacja idei biblioteki Parallel}

  Niniejsza sekcja przedstawia inspiracjê oraz wynik koñcowy pracy koncepcyjnej nad bibliotek±.
  Zostan± zarysowane wysokopoziomowa architektura biblioteki oraz funkcjonowanie biblioteki z punktu widzenia programisty-u¿ytkownika.

\subsection{Inspiracja}

  Powstanie biblioteki zosta³o zainspirowane bibliotek± do prowadzenia obliczeñ równoleg³ych w jêzyku Haskell, Parallel Haskell\cite{parhas}.
  Ta biblioteka pozwala w sposób bardzo intuicyjny obliczaæ dwa wyra¿enia równolegle.
  Oto przyk³ad funkcji obliczaj±cej w sposób równoleg³y n-t± liczbê Fibonacciego:
  \begin{lstlisting}[language=Haskell]
    import Control.Parallel

    nfib :: Int -> Int
    nfib n | n <= 1 = 1
       | otherwise = par n1 (seq n2 (n1 + n2))
                     where n1 = nfib (n-1)
                           n2 = nfib (n-2)
  \end{lstlisting}
  
  Analogiczny program sekwencyjny wygl±da³by nastêpuj±co:
  \begin{lstlisting}[language=Haskell]
    import Control.Parallel

    nfib :: Int -> Int
    nfib n | n <= 1 = 1
       | otherwise = (n1 + n2)
                     where n1 = nfib (n-1)
                           n2 = nfib (n-2)
  \end{lstlisting}
  
  W Haskellu funkcja \verb|par| wskazuje, ¿e wyliczenie dwóch wyra¿eñ mo¿e odbyæ siê równolegle i w czasie wykonania podejmowana jest decyzja o sposobie wyliczenia.
  Obliczenia odbywaj± siê równolegle, gdy jest to bardziej efektywne od wykonania sekwencyjnego.
  Ta konstrukcja pokazuje z jak zadziwiaj±c± prostot± mo¿na pisaæ programy równoleg³e.
  W Haskellu wystarczy dodaæ jedno s³owo, aby oznaczyæ wyra¿enie jako przeznaczone do zrównoleglenia.
  Taka by³a pierwotna inspiracja dla zbudowania biblioteki Parallel.
  Przekazanie wyra¿enia do odpowiedniej funkcji powinno poskutkowaæ jego zrównolegleniem.
  
\subsection{Zlecanie obliczeñ}\label{ss:zlecanie}

  Zlecanie równoleg³ego wykonania obliczeñ powinno jak najmniej ingerowaæ w sekwencyjny kod programu dla zachowania jego intuicyjno¶ci.
  (Dla wyja¶nienia dodam, ¿e nie twierdzê, i¿ jedynie sekwencyjny kod programu mo¿e byæ intuicyjny, jednak praktyka pokazuje, ¿e zrozumienie programu, 
  który zosta³ zapisany jako kilka jednocze¶nie wykonywanych ci±gów instrukcji jest znacznie trudniejsze od zrozumienia programu sekwencyjnego.)
  Do oznaczenia wyra¿enia, które ma zostaæ wykonane równolegle bêdzie s³u¿y³a funkcja \verb|eval|, przyjmuj±ca jako argument wyra¿enie do wykonania.
  Obliczenie przekazanego wyra¿enia odbêdzie siê równolegle.
  
  Sk³adnia wyra¿eñ powinna byæ jak najbardziej zbli¿ona do sk³adni jêzyka C++, bo to by konstruowanie wyra¿eñ by³o ³atwe dla programisty.
  Idealnie by³oby, gdyby programista móg³ przekazaæ wyra¿enie w jego standardowej postaci w jêzyku C++, czyli w nastêpuj±cy sposób:
  \begin{lstlisting}[numbers=none, frame=none]
    parallel::eval(fibonacci_od(40));
  \end{lstlisting}
  W tej chwili czytelnik dobrze zaznajomiony z semantyk± jêzyka C++ móg³ dostrzec pewien problem do pokonania zwi±zany z przekazaniem wyra¿enia do wykonania.
  W podanym przyk³adzie takie wyra¿enie najpierw zosta³oby wyliczone, poniewa¿ jêzyk C++ posiada gorliw± semantykê wyliczania wyra¿eñ, a dopiero nastêpnie by³oby przekazane do funkcji \verb|eval|.
  Zatem funkcja eval otrzyma³aby gotowy wynik i ¿adne równoleg³e obliczenia nie by³yby ju¿ potrzebne.
  Takiej sytuacji nale¿y unikn±æ poprzez zaprojektowanie specjalnego sposobu przekazywania wyra¿eñ do funkcji \feval.
  Zabieg, który nale¿y zastosowaæ nazywa siê uleniwieniem wyra¿enia i polega na odroczeniu obliczenia warto¶ci wyra¿enia do momentu, gdy ta warto¶æ bêdzie potrzebna.
  Wyra¿enie leniwe nie jest wyliczane w miejscu pojawienia siê.
  Dziêki zastosowaniu takiem metody wyra¿enie, które ma byæ wyliczone równolegle pojawia siê w kodzie tam, gdzie jest to najwygodniejsze, w jawnej postaci, a potem mo¿e zostaæ przekazane od mechanizmu ewaluacji biblioteki Parallel.
  
\subsubsection{Leniwe wyra¿enia w jêzyku C++}

  Stworzenie leniwego wyra¿enia w jêzyku C++ nie wydaje siê prostym zadaniem.
  Domy¶lna semantyka obliczeñ jest gorliwa, nie ma s³ów kluczowych pozwalaj±cych na dodanie leniwo¶ci, C++ nie pozwala równie¿ na rozszerzenie sk³adni jêzyka.
  Wskazówka do rozwiazanie problemu leniwych wyra¿eñ w jêzyku C++ znajduje siê w ksi±¿ce \textit{More C++ Idioms}\cite{idioms}, która przedstawia idiom C++ szablonu wyra¿enia (z ang. Expression Template).
  Idea stworzenia szablonu wyra¿enia polega na reprezentacji wyra¿enia przez zbudowanie odpowiedniego drzewa typów, które jest Abstrakcyjnym Drzewem Syntaktycznym (z ang. Abstract Syntax Tree - AST) wyra¿enia.
  Dok³adny opis zastosowanej metody znajduje siê w rozdziale po¶wiêconym implementacji biblioteki.
  
  \subsubsection{Funkcja \texttt{eval}}\label{sss:eval}

  Jeszcze s³owo w rozdziale przedstawiaj±cym koncepcje biblioteki nale¿y siê funkcji \feval, która jest g³ówn± funkcj± z API dostêpnego dla programisty.
  Funkcja s³u¿y do zlecenia wykonania obliczeñ równoleglych.
  W ciele funkcji znajduje siê przekazanie wyra¿enia w formie leniwej do mechanizmu ewaluacyjnego.
  Warto¶æ zwracana przez funkcjê powinna udostêpniaæ mo¿liwo¶æ sprawdzenia wyniku obliczenia.
  Przekazywanie wyników obliczeñ przez bibliotekê Parallel zosta³o omówione w sekcji \nameref{s:koncepcja_wynik}.
  
\subsection{Wykonanie zadañ}\label{ss:wykonywanie}

  W tej podsekcji zostanie omówiony mechanizm wyliczania wyra¿eñ w bibliotece Parallel po przekazaniu ich do funkcji \texttt{eval}.
  Jest to serce biblioteki, dziêki któremu biblioteka potrafi pe³niæ swoje funkcje.
  
  \subsubsection{Dzia³anie mechanizmu ewaluacji}
  
  Ewaluacja wyra¿eñ przekazanych do obliczenia bêdzie odbywa³a siê zgodnie z wzorcem producent-konsument.
  Producentem wyra¿eñ bêdzie kod programu korzystaj±cego z biblioteki Parallel i przekazuj±cy wyra¿enia przy pomocy funkcji \texttt{eval}.
  Natomiast konsumentem bêd± w±tki-pracownicy biblioteki Parallel, których jedynym zadaniem bêdzie oczekiwanie na zadania (wyra¿enia do ewaluacji) i ich wykonywanie.
  Ze wzglêdu na efektywno¶æ wykorzystany zostanie wzorzec puli w±tków (thread pool opisany w \cite{threadpool}).
  Zatem w±tek nie bêdzie tworzony dla wykonania ka¿dego zadania, a bêdzie istnia³a grupa w±tków dedykowanych do wykonywania obliczeñ, która bêdzie zaalokowana w programie tak d³ugo jak program bêdzie korzysta³ z biblioteki Parallel.
  O liczbie w±tków bêdzie decydowa³ u¿ytkownik, gdy¿ ich liczba mo¿e mieæ znacz±cy wp³yw na wydajno¶æ programu, a nie istnieje optymalna liczba w±tków dla ka¿dego rodzaju zastosowania biblioteki Parallel.
  Standardowo w tym modelu wyra¿enia bêd± trafia³y do kolejki zadañ, w której bêd± oczekiwa³y na wyliczenie.
  
  Mo¿e siê zdarzyæ, ¿e wyra¿enie nie zostanie wyliczone do momentu gdy bêdzie potrzebne w programie, który przekaza³ je do obliczenia.
  W tej sytuacji biblioteka Parallel reaguje w takie sposób, by nie blokowaæ programu bez przyczyny.
  Program dotar³by do takiego miejsca, ¿e potrzebuje wyliczonego wyra¿enia przekazanego do Parallel, a nie zosta³o jeszcze wykonane, program musia³by oczekiwaæ na wykonanie obliczeñ.
  Skoro program nie ma nic innego do wykonania to w±tek programu sam mo¿e wyliczyæ wyra¿enie, odpowiednio informuj±c bibliotekê Parallel, aby wyra¿enie nie zosta³o wykonane kilkakrotnie, 
  gdy¿ nierozs±dne by³oby narzucanie ograniczenia nakazuj±cego, ¿eby wyra¿enia przekazywane do biblioteki Parallel by³y idempotentne.
  Ca³o¶ci± procesu alternatywnego wyliczania obliczenia przez w±tek programu powinna zarz±dzaæ biblioteka, tak aby nie by³o to zauwa¿alne dla programisty.
  
  Jednym z rozszerzeñ mechanizmu ewaluacji mog³oby byæ dodanie automatycznego dostosowywania liczby w±tków w puli do intensywno¶ci prowadzonych obliczeñ.
  W pierwszej wersji biblioteki nie przewidziano w projekcie takiej funkcjonalno¶ci.
  
  W bibliotece nie wystêpuje problem balansowania obci±¿enia ró¿nych w±tków, gdy¿ wszystkie w±tki nale¿±ce do puli s± identycznie i dziêki wykorzystaniu wspólnej kolejki zadañ, obci±¿enie jest równowa¿one samoczynnie.
  W±tek koñcz±c pracê nad jednym zadaniem siêga do kolejki po nastêpne.
  
\subsubsection{Mechanizmy synchronizacji}

  Dla poprawno¶ci dzia³ania biblioteki niezbêdne by³o zaimplementowanie mechanizmów synchronizacji w±tków-pracowników oraz kodu programu. 
  Zosta³y one opisane w sekcji \nameref{s:ewaluacja}.
  U¿ywaj±c biblioteki Parallel programista nie musi martwiæ siê o synchronizacjê dzia³ania biblioteki Parallel.
  
  Biblioteka nie mo¿e jednak przewidzieæ zale¿no¶ci w kodzie programu, dlatego ochrona danych, na których dokonywane s± obliczenia pozostaje w rêkach programisty.
  Parallel nie narzuca ¿adnych ograniczeñ, co do korzystania w kodzie zrównoleglanych wyra¿eñ instrukcji dostêpu do struktur danych, z których korzysta wiele w±tków jednoczesnie.
  W tej sytuacji programista musi zadbaæ o odpowiednie umieszczenie sekcji krytycznych w kodzie obliczanych wyra¿eñ, tak aby program by³ bezpieczny i ¿ywotny.
  
\subsection{Sposób przekazywania wyniku}\label{s:koncepcja_wynik}

  Kod korzystaj±cy z biblioteki Parallel powinien wygl±daæ naturalnie.
  Skoro do funkcji \texttt{eval} przekazujemy wyra¿enie, to naturalnym oczekiwaniem jest to, ¿e w wyniku ewaluacji otrzymamy warto¶æ tego wyra¿enia.
  Problem le¿y w tym, ¿e  je¶li warto¶æ by³aby zwracana w momencie powrotu z funkcji \texttt{eval} to otrzymaliby¶my \textit{de facto} program sekwencyjny, choæ roz³o¿ony na kilka w±tków,
  nie by³oby mo¿liwo¶ci wykorzystania korzy¶ci z równoleg³ego prowadzenia obliczeñ na wielu w±tkach.
  Dlatego wywo³anie obliczenia wyra¿enia przez funkcjê \feval biblioteki Parallel nie zwraca wyniku natychmiast,
  a kod programu przechodzi do kolejnych instrukcji.
  W momencie powrotu z funkcji \feval bêdzie znany jedynie typ wyra¿enia, a nie jego warto¶æ.
  Warto¶æ zostanie obliczona pó¼niej przez mechanizm ewaluacji biblioteki Parallel.
  
  To podej¶cie w jêzyku fachowym nazywa siê komunikacj± asynchroniczn± i czêsto pojawia siê w kontek¶cie programowania wspó³bie¿nego.
  Wykorzystuj± je takie technologie jak asynchroniczne zdalne wywo³anie procedur (z ang. Asychronous RPC), zdalne wywo³anie metod w jêzyku Java ??
  Jego przeciwieñstwem, w którym wynik funkcji jest zwracany w momencie powrotu z funkcji wywo³uj±cej równoleg³e obliczenie, jest komunikacja synchroniczna.
  Wybór asynchronicznego sposobu zwracania wyniku pozwala na nastêpuj±ce optymalizacje:
  \begin{itemize}
   \item Gdy w±tek g³ówny nie wymaga wyniku ani informacji o zakoñczeniu zadania, to po prostu mo¿e pój¶æ dalej i wykonywaæ inne instrukcje.
   \item W±tek g³ówny mo¿e uruchomiæ kilka równoleg³ych obliczeñ jednocze¶nie.
   \item W±tek g³ówny mo¿e uruchomiæ obliczenia, wykonywaæ inne instrukcje i odebraæ wynik pó¼niej, w momencie, gdy to jest niezbêdne. 
  \end{itemize}
  
\subsubsection{Omówienie asynchronicznych sposobów zwracania wyniku}
  Programowanie w sposób asynchroniczny jest trudniejsze, gdy¿ programista musi w odpowiedni sposób zarz±dzaæ asynchronicznymi obliczeniami.
  Generalnie istniej± dwa sposoby zwracania wyniku z asynchronicznego.
  Oba zosta³y opisane w ksia¿ce \cite{dissys} w rozdziale dotycz±cym Asychronicznego Zdalnego Wywo³ania Procedur (z ang. Asychronous RPC).
  
  Pierwszy ze sposobów to sposób jawny, w którym asynchroniczne wywo³anie pewnej funkcji zwraca identyfikator wyniku.
  Nastêpnie w±tek, który wywo³a³ tê funkcjê mo¿e przy pomocy identyfikatora odpytywaæ o wynik (z ang. polling) proces wykonuj±cy obliczenie.
  
  Drugi sposób jest niejawny, poniewa¿ kod programu nie obs³uguje zwracanego wyniku \textit{explicite}.
  Mechanizm polega na tym, ¿e proces wykonuj±cy obliczenie wywo³uje pewn± funkcjê, której przekazuje obliczony wynik i ta funkcja odpowiada za dalsze przetwarzanie wyniku.
  Jest to tak zwane zwrotne wywo³anie funkcji (z ang. callback).
  
  W kontek¶cie projektowania biblioteki Parallel natychmiast odrzucone zosta³o wykorzystanie drugiego z opisanych sposobów, poniewa¿ sta³by on w zdecydowanej sprzeczno¶ci z celami biblioteki.
  W przypadku niejawnego sposobu przetwarzania wyniku, kod programu u¿ywaj±cego biblioteki Parallel sta³by siê mniej czytelny i trudniejszy do analizy.
  Zlecenie obliczenia i odebranie wyniku by³oby opisane przez dwa ró¿ne odleg³e od siebie miejsca w kodzie.
  
  Zdecydowanie bli¿szy idei biblioteki Parallel jest sposób pierwszy.
  Jednak¿e zdecydowana wiêkszo¶æ tego typu rozwi±zañ zrzuca on na programistê obowi±zek aktywnego jawnego odpytywania o wynik.
  Nie jest to rozwi±zaniem z³ym, ale zmusza programistê do zaprogramowania dodatkowych czynno¶ci.
  Na przyk³ad, programista musi obs³u¿yæ zarówno sytuacjê, gdy wynik ju¿ jest dostêpny, oraz sytuacjê, gdy obliczenie nie zosta³o jeszcze wykonane.
  W celu pozwolenia programistom na bardziej produktywn± pracê warto by³o poszukaæ lepszego rozwiazania.
  
\subsubsection{Synchroniczne zwracanie odroczonego (asynchronicznego) wyniku}  

  Rozwi±zanie zaprojektowane dla biblioteki Parallel opiera siê na asynchronicznym zwracaniu wyniku, ale asynchroniczno¶æ jest ukryta przed programist±.
  Z jego punktu widzenia kod programu dzia³a tak, jakby wynik zosta³ zwrócony w sposób synchroniczny.
  To wyja¶nia tytu³ nadany tej podsekcji.

  Zosta³o to osi±gniête poprzez wprowadzenie klasy obudowuj±cej warto¶æ zwracan±, uchwytu do wyniku, który nazwiemy warto¶ci± odroczon± (z ang. deferred value).
  Aby warto¶æ odroczona ¶ci¶le odpowiada³a typowi wynikowemu wyra¿enia, bêdzie ona szablonem typu parametryzowanym typem wynikowym wyra¿enia.
  Dziêki temu, ¿e znany by³ typ zwracany, mo¿liwe jest takie zaprojektowanie klasy warto¶ci odroczonej, ¿e przypomina w swoim zachowaniu typ wynikowy wyra¿enia.
  
  Warto¶ci odroczonej mo¿na u¿ywaæ prawie zamiennie z typem, który obudowuje.
  To dziêki temu, ¿e jest dostêpna niejawna konwersja do obudowywanego typu, a zastosowanie operatorów bêdzie dawa³o identyczny wynik.
  W momencie, gdy warto¶æ wyra¿enia bêdzie niezbêdna nast±pi wymuszenie ewaluacji, je¶li warto¶æ nie zosta³a jeszcze wyliczona, i pobranie wyniku.
  Przyk³adem takiej sytuacji jest przypisanie warto¶ci odroczonej na zmienn± o typie warto¶ci obudowywanej.
  Odbêdzie siê wtedy niejawna konwersja, do której bêdzie potrzebna rzeczywista warto¶æ wyra¿enia.
  
\subsubsection{Obs³uga sytuacji wyj±tkowych}
  Nale¿y równie¿ przyjrzeæ siê sytuacji, w której w czasie obliczania wyra¿enia wyst±pi b³±d, zasygnalizowany przez rzucenie wyj±tku.
  Biblioteka Parallel powinna wspieraæ obs³ugê takiej sytuacji w kodzie.
  Aby reakcja ze strony programisty by³a mo¿liwa wyj±tek musi zostaæ z³apany i zasygnalizowany programi¶cie.
  Przepuszczenie wyj±tku przez bibliotekê skutkowa³oby natychmiastowym b³êdnym zakoñczeniem programu, 
  gdy¿ programista nie mia³by ¿adnej mo¿liwo¶ci z³apania wyj±tku, gdy¿ wyj±tek ten pochodzi³by z kodu biblioteki Parallel wykonywanym w innym w±tku.
  Biblioteka nie powinna równie¿ t³umiæ wszystkich wyj±tków, gdy¿ programista nie wiedzia³by wtedy co siê dzieje w programie, a warto¶æ przypisana na warto¶æ odroczon± by³aby niezdefinowana.
  
  Nasuwa siê zatem rozwi±zanie, w którym biblioteka wy³apywa³aby wyj±tki wywo³ane w obliczanych wyra¿eniach, ale przekazywane by³yby one do w±tku g³ównego programu.
  Mo¿e to nast±piæ jedynie za po¶rednictwem warto¶ci odroczonej, poniewa¿ powrót z funkcji \feval nastêpuje zazwyczaj przed rozpoczêciem obliczania wyra¿enia.
  Warto¶æ odroczona ma ustalony typ, wiêc warto¶æ odroczona nie mo¿e zwróciæ wyj±tku.
  Jednak¿e, to co mo¿e zostaæ wykonane to ponowne rzucenie wy³apanego i przekazanego do warto¶ci odroczonej wyj±tku przy próbie pobrania wyliczonej warto¶ci.
  Wtedy wyj±tek powsta³y w obliczeniach by³by przekazywany do kodu g³ównego w±tku i programista mia³by mo¿liwo¶æ jego obs³ugi w dobrze zdefinowanym miejscu.
  
% \subsubsection{Metody klasy reprezentuj±cej uchwyt do wyniku}
% 
%   Interfejs publiczny klasy reprezentuj±cej uchwyt do wyniku bêdzie zawiera³ metody:
% \begin{itemize}
%  \item pobrania warto¶ci,
%  \item sprawdzenia czy warto¶æ zosta³a ju¿ wyliczona,
%  \item operator konwersji do typu wyniku wyra¿enia
% \end{itemize}
% 
% \paragraph{Operatory}~\\
%   Ponadto w interfejsie klasy obudowuj±cej wynik bêd± znajdowa³y siê wszystkie operatory, które maj± sens dla typu obudowywanego.
%   Oczywi¶cie ze wzglêdu na  ograniczenia jêzyka niemo¿liwe jest zdefinowanie operatorów, których prze³adowywanie jest zabronione, takich jak \verb|.| oraz \verb|.*|.
%   
%   Mo¿liwa jest taka sytuacja, w której wykorzystanie warto¶ci odroczonej w wyra¿eniu nie bêdzie wymusza³o natychmiastowego wyliczenia warto¶ci odroczonej.
%   We¼my jako przyk³ad nastepuj±c± instrukcjê:
% \begin{verbatim}
%   auto c = odroczony_int + 42;
% \end{verbatim}
%   Czy musimy znaæ warto¶æ odroczony\_int, aby przypisaæ odpowiedni± warto¶æ na zmienn± c?
%   To zale¿y w tym przypadku od implementacji operatora \verb|+|.
%   Je¶li operator dodawania bêdzie tak zaprojektowany, ¿e dodanie warto¶ci odroczonej sparametryzowanej typem int oraz liczby ca³kowitej zwraca inta, to oczywi¶cie warto¶æ odroczona musi byæ znana.
%   Natomiast dziêki temu, ¿e przytoczona w przyk³adzie instrukcja zawiera pewn± dowolno¶æ w postaci automatycznego typowania zmiennej c, to nic nie stoi na przeszkodzie, ¿eby c by³o równie¿ warto¶ci± odroczon±.
%   I taka decyzja projektowa zosta³a podjêta w bibliotece Parallel.
%   Operatory bêd± zwracaæ warto¶æ typu warto¶æ odroczona, aby prowadziæ obliczenia w taki sposób, ¿e wymuszenie obliczenia warto¶ci odroczonej by³o od³o¿one najpó¼niej jak to mo¿liwe.
%   Warto¶æ odroczna zwracana przez operatory, bêdzie zawiera³a leniwe wyra¿enie podobne do tego, które jest przekazywane funkcji \verb|eval|.
%   W momencie wymuszenia wyliczenia takiej warto¶ci odroczonej to leniwe wyra¿enie zostanie wyliczone.
%   Pozwoli to na lepsze zrównoleglenie obliczeñ, poniewa¿ umo¿liwie przeprowadzenie wiêkszej liczby obliczeñ przez w±tki-pracowników z biblioteki Parallel.
%   
%\subsubsection{Wp³yw sposobu przekazywania wyniku na cele biblioteki Parallel}

\subsection{Schemat interakcji kodu programu z bibliotek± Parallel}

  Podsumowania opisu idei biblioteki Parallel dokonam poprzez opisanie pokrótce tego jak kod aplikacji pisany przez programistê wspó³pracuje z kodem biblioteki Parallel.
  Schematycznie ilustruje to poni¿szy diagram.
\begin{figure}[h!]
 \includegraphics[width=\textwidth]{interaction.eps}
 \caption{Schemat interakcji z bibliotek± Parallel}
\end{figure}

  Schemat pokazuje jak w pierwszej kolejno¶ci kod programu wywo³uje funkcjê \feval, która s³u¿y do zlecenia obliczenia równoleg³ego wyra¿enia.
  Nastêpnie sterowanie przechodzi do cia³a funkcji \feval, czyli do kodu biblioteki Parallel.
  Funkca \feval tworzy niezbêdne struktury danych oraz dodaje wyra¿enie \verb|exp| do wyra¿eñ czekaj±cych na wyliczenie.
  Potem nastêpuje powrót z funkcji \feval ze zwróceniem warto¶ci odroczonej \verb|d| i na jaki¶ czas kod programu i biblioteki Parallel zaprzestaj± komunikacji.
  Kod programu wykonuje w³asne instrukcje, a kod Parallel wykonuje w³asne zadania, miêdzy innymi wyliczaj±c wyra¿enia, które zosta³y wskazane do wyliczenia równoleg³ego.
  Takie wyliczenie zachodzi w pewnym momencie w czasie równiez dla wyra¿enia \verb|exp|.
  
  Gdy nadchodzi moment w kodzie programu, gdy potrzebna jest wyliczona warto¶æ wyra¿enia to nastêpuje automatycznie próba pobrania warto¶ci wyra¿enia z warto¶ci odroczonej \verb|d|.
  Wtedy nastêpuje przekazanie sterowania do kodu biblioteki, który przekazuje z powrotem wyliczon± warto¶æ wyra¿enia \verb|exp|.
  Kod programu otrzymuje warto¶æ i mo¿e dalej prowadziæ swoje obliczenia.
  Tak wygl±da jeden cykl skorzystania z mechanizmu zlecania wyra¿eñ do równoleg³ego wyliczenia w bibliotece Parallel.
  
\newpage
\input{other_models}

\newpage
\section{Zaawansowane przyk³ady u¿ycia biblioteki Parallel}

  Opis koncepcji biblioteki Parallel zakoñczê pokazaniem zaawansowanych przyk³adów wykorzystania biblioteki Parallel do prowadzenia równoleg³ych obliczeñ.
  W pierwszym z przyk³adów poka¿e w jaki sposób biblioteka Parellel mo¿e s³u¿yæ do zrównoleglenia algorytmu szybkiego sortowania (z ang. quicksort).
  Drugi przyk³ad wykorzystuj±cy w jeszcze wiêkszej mierze mo¿liwo¶ci biblioteki Parallel poka¿e zdecydowan± przewagê biblioteki Parallel nad standardow± bibliotek± do obs³ugi wielu w±tków Boost.Threads.
  
\subsection{Równoleg³e szybkie sortowanie}

  Moja implementacja zrównoleglonego szybkiego sortowania opiera siê na prostej idei ``dziel i zwyciê¿aj''. 
  W ka¿dym rekurencyjnym wywo³aniu funkcji \verb|parallel_quicksort| na pocz±tku wywo³ywana jest funkcja \verb|partition|, 
  dziel±ca tablicê na czê¶ci o elementach mniejszych od pewnego wyró¿nionego elementu i o elementach wiêkszych od tego¿ elementu.
  Nastêpnie, je¶li podtablice do posortowania s± wystarczaj±co du¿e (w przyk³adzie limit zosta³ ustalony na 100 elementów) to wywo³ywana jest rekurencyjnie funkcja \verb|parallel_quicksort|.
  Je¶li podtablica jest mniejsza to jest sortowana standardowym algorytmem sekwencyjnym szybkiego sortowania.
  
  Implementacje dostarczy³em w dwóch wersjach.
  Jedna jest zaimplementowana przy u¿yciu biblioteki Boost.Threads, a druga przy u¿yciu biblioteki Parallel.
  Oto implementacja wykorzystuj±ca standardow± bibliotekê do obs³ugi wielow±tkowo¶ci:
  \begin{lstlisting}
const unsigned limit = 100;
  
template <typename Item>
void thread_quicksort(Item array[], size_t l, size_t r)
{
  if (l < r)
  {
    size_t s = partition(array, l, r);
    boost::thread thread;
    if (s - l > limit) 
      thread = boost::thread(
	boost::bind(quicksort<int>, array, l, s - 1));
    else
      quicksort(array, l, s - 1);
    quicksort(array, s + 1, r);
    if (s - l > limit)
      thread.join();
  }
}
  \end{lstlisting}
  
  Jak widzimy dla ka¿dego równoleg³ego wywo³ania funkcji \verb|paralell_quicksort| musi zostaæ stworzony w±tek, poniewa¿ Boost.Threads nie posiada puli w±tków.
  \footnote{Oczywi¶cie pulê w±tków mo¿na zaimplementowaæ wykorzystuj±c Boost.Threads, ale moim celem by³o pokazanie przyk³adów zrównoleglenia szybkiego sortowania, 
  których napisanie by³o podobne pod wzglêdem struktury kodu i pracoch³onno¶ci.}
  W przypadu du¿ych tablic mo¿e to skutkowaæ spowolnieniem dzia³ania programu z powodu zbyt du¿ego obci±¿enia systemu w±tkami i zbyt czêstych prze³±czeñ kontekstu.
  
  W poni¿szy sposób wygl±da analogiczna implementacja szybkiego sortowania korzystajaca z biblioteki Parallel:
  \begin{lstlisting}
const unsigned limit = 100;
  
template <typename Item>
void parallel_quicksort(Item array[], size_t l, size_t r)
{
  if (l < r)
  {
    size_t s = partition(array, l, r);
    deferred_value<void> tmp;
    if (s - l > limit)
      tmp = parallel::eval(
	parallel::lazyf(quicksort<int>, array, l, s - 1));
    quicksort(array, s + 1, r);
    if (s - l > limit)
      tmp.force();
  }
}
  \end{lstlisting}
  
  Ta implementacja ma tê przewagê, ¿e w±tki s± tworzone tylko raz, podczas inicjalizacji biblioteki Parallel i ich ilo¶æ jest ustalona.
  Zatem nie jest mo¿liwe przeci±¿enie systemu niekontrolowanym rozmno¿eniem siê w±tków.
  Poza istotn± korzy¶ci± zwi±zan± z brakiem potrzeby zarz±dzania w±tkami, w samej strukturze programu nie widaæ znacz±cych korzy¶ci z wyboru biblioteki Parallel.
  Kod wygl±da bardzo podobnie.
  Aby pokazaæ zalety Parallel w porównaniu ze standardowymi bibliotekami bêdzie potrzebny kolejny przyk³ad.

\subsection{Równoleg³e sumowanie elementów tablicy}

  Przyk³ad zrównoleglenia sumowania elementów tablicy poka¿e jak wygodna jest sk³adnia bibioteki Parallel 
  w porównianiu ze sk³adni± biblioteki Boost.Threads, gdy równoleg³e obliczenia musz± zwróciæ pewn± warto¶æ.
  
  Tak wygl±da implementacja wielow±tkowa napisana w oparciu o Boost.Threads:
  \begin{lstlisting}
void sum(int* wynik, int* begin, int* end)
{
  *wynik = 0;
  for (int* i = begin; i != end; i++) *wynik += *i;
}  

int array_sum_thread(int* array, size_t size)
{
  int s1, s2, s3, s4;
  boost::thread t1(
    boost::bind(sum, &s1, array, array + size/4));
  boost::thread t2(
    boost::bind(sum, &s2, array + size/4 + 1, array + size/2));
  boost::thread t3(
    boost::bind(sum, &s3, array + size/2 + 1, 3*size/4));
  boost::thread t4(
    boost::bind(sum, &s4, array + 3*size/4 + 1, array + size));
  t1.join();
  t2.join();
  t3.join();
  t4.join();
  return s1 + s2 + s3 + s4;
}
  \end{lstlisting}
  W tej implementacji niezbêdne by³o zaimplementowanie funkcji sumuj±cej pewien odcinek tablicy, który zwraca wynik przez jeden z argumentów,
  poniwa¿ w±tki nie zwracaj± ¿adnych warto¶ci.
  Oczywi¶cie, w przypadku tak prostej implementacji nie ma mo¿liwo¶ci ¿adnej obs³ugi b³êdów, które mog± pojawiæ siê podczas obliczeñ.
  Ponadto programista musia³ zadbaæ o synchronizacjê w±tków, w tym przypadku poprzez wywo³anie funkcji \verb|join| na ka¿dym z w±tków.
  
  Nieco inaczej wygl±da funkcja napisana przy pomocy biblioteki Parallel:
  \begin{lstlisting}
int sum(int* begin, int* end)
{
  int s = 0;
  for (int* i = begin; i != end; i++) s += *i;
  return s;
}
  
int array_sum_parallel(int* array, size_t size)
{
  deferred_value<in> sum = parallel::evaluate(
    *parallel::lazyf(sum, array, array + size/4));
  for (int i = 1; i < 4; i++)
  {
    sum += parallel::evaluate(parallel::lazyf(
      sum, array + (i * size)/4 + 1, array + ((i+1) * size)/4));
  }
  return sum;
}
  \end{lstlisting}
  Funkcja sumuj±ca tablicê w tym przyk³adzie ma czê¶ciej spotykan± postaæ, w której wynik zwracany jest w standardowy sposób.
  W zwi±zku z tym czêsto w praktycznych zastosowaniach bêdzie mo¿na zastosowaæ istniej±c± funkcjê, co zwiêkszy czêsto¶æ ponownego u¿ycia kodu.
  W przyk³adzie nie widaæ ¿adnego ¶ladu jawnej synchronizacji pomiêdzy w±tkami.
  Dziêki odpowiedniej implementacji warto¶ci odroczonych synchronizacja zarz±dzana jest automatycznie przez bibliotekê.
  Pomimo tego, ¿e w linii 13. przyk³adu sum jest u¿ywane to prze³adowanie operatora \verb|+=| sprawia, ¿e obliczenie warto¶ci odroczonej nie jest wymuszane
  i wszystkie obliczenia wykonuj± siê równocze¶nie.
  Dopiero w linii 15, gdzie warto¶æ odroczona \verb|sum| jest konwertowana do \verb|int| nastêpuje pobranie wyniku ze wszystkich zleconych obliczeñ i zwrócenie warto¶ci.
 