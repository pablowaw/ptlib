\chapter{Opis implementacji}\label{r:implementacja}

  W tym rozdziale zostan± opisane szczegó³y implementacyjne biblioteki Parallel.
  Nie jest moim celem pe³ne opisanie ca³o¶ci kodu, które by³oby bardzo obszerne i mêcz±ce dla czytelnika.
  Swoj± uwagê skoncentrujê na najciekawszych aspektach implementacji biblioteki, które nios³y ze sob± pewne problemy do rozwi±zania i wywar³y najwiêkszy wp³yw na wynik finalny.
  
\section{Architektura biblioteki}

  Poni¿ej znajduje siê diagram pokazuj±cy g³ówne komponenty biblioteki wraz z zale¿no¶ciami miêdzy nimi.
  Podczas omawiania implementacji biblioteki Parallel bêdê odwo³ywa³ siê do elementów przedstawionego schematu.
  Pozwoli to na lepsze zrozumienie pó¼niejszych rozwa¿añ.
  
\begin{figure}[h!]
 \includegraphics[width=\textwidth]{architecture.eps}
 \caption{Schemat architektury biblioteki Parallel}
\end{figure}

  Na diagramie nie znajduj± siê wszystkie metody zaimplementowane w poszczególnych klasach, a jedynie te niezbêdne do zaprezentowania architektury biblioteki.
  
\subsection{API biblioteki}

  Kod programu komunikuje siê z bibliotek± poprzez API. Oto krótkie wyja¶nienie znaczenia poszczególnych funkcji z API:
  G³ówn± funkcj± z API jest funkcja \feval, której znaczenie zosta³o opisane w sekcji \nameref{sss:eval}.
  Pozosta³e funkcje maj± zadanie pomocnicze w stosunku do \feval.
  S± niezbêdne do stworzenia wyra¿enia, które funkcja \feval mo¿e przyj±æ do wyliczenia.
  I tak funkcja \verb|val| pozwala przekazaæ swój argument do wyra¿enia przez warto¶æ, \verb|cval| przez warto¶æ sta³±, \verb|ref| przez referencjê, \verb|cref| przez sta³± referencjê.
  Ponadto, w API znajduje sie wzorzec funkcji pozwalaj±cy na uleniwione wywo³ywanie funkcji, \verb|lazyf|.
  Rola i sposób implementacji tych funkcji s± opisane w sekcji \nameref{s:przekazywanie_wyrazen}.
  
  Nale¿y dodaæ, i¿ program korzystaj±cy z biblioteki Parallel musi przed rozpoczêciem zlecania wyra¿eñ do obliczenia wywo³aæ funkcjê \verb|init|
  inicjalizuj±c± bibliotekê i ustalaj±c± liczbê w±tków w puli mechanizmu ewaluacji.
  Korzystanie z biblioteki Parallel powinno zakoñczyæ siê wywo³aniem funkcji \verb|close|, która zwalnia zasoby zaalokowane przez bibliotekê.
  
\subsection{Operacje wykonywane w kodzie biblioteki Parallel}\label{ss:operacje}

  Odpowiednio stworzone wyra¿enie jest przetwarzane przez funkcjê \feval.
  W ciele funkcji z wyra¿enia tworzony jest obiekt typu \verb|deferred_expr|, który reprezentuje zadanie do wykonania.
  Zadanie jest dodawane do kolejki zadañ w obiekcie \emgr przy u¿yciu metody \verb|add_for_eval|.
  Aparat wykonawczy w postaci instancji typu \emgr zawiera, oprócz kolejki zadañ do wykonania, równie¿ w±tki, którymi zarz±dza, i które wykonuj± zadania dzia³aj±c w nieskoñczonej pêtli w funkcji \verb|eval_loop|.
  
  Ka¿dy obiekt typu \verb|deferred_expr| jest po³±czony 1-1 z obiektem typu \dval, który reprezentuje wynik obliczenia wyra¿enia.
  Je¶li zadanie zdefinowane przez wyra¿enie zapamiêtane w obiekcie \dexp zostaje wykonane, to wynik (je¶li istnieje) zostaje przypisany na pole \verb|m_value| w skojarzonym obiekcie typu \dval.
  
\subsection{Zwrócenie wyniku}
  
  Wynik jest przekazywany do kodu programu poprzez obiekt typu \verb|deferred_value|, który jest zwracany jako wynik funkcji \feval.
  Je¶li nast±pi wywo³anie pobrania warto¶ci z obiektu typu \dval metod± \verb|get_value| lub wymuszenie wyliczenia warto¶ci przez metodê \verb|force|, wyliczenie wyra¿enia zostaje wymuszone, o ile nie zosta³o ju¿ wykonane.
  
  
\section{Implementacja przekazywania wyra¿eñ do wyliczenia}\label{s:przekazywanie_wyrazen}
  
  Jednym z najtrudniejszych zadañ podczas fazy implementacji biblioteki Parallel by³o zaprojektowanie przekazywania wyra¿eñ do wykonania.
  Mechanizm mia³ stanowiæ wa¿n± czê¶æ API biblioteki, które powinno wspieraæ spe³nienie wyznaczonych dla biblioteki celów czytelno¶ci i intuicyjno¶ci.
  Te cele niew±tpliwie by³yby zrealizowane, gdyby mo¿liwe by³o przekazywanie wyra¿eñ w ich standardowej postaci w jêzyku C++.
  Jednak problem stanowi³ fakt, i¿ jêzyk C++ posiada gorliw± semantykê wyliczania wyra¿eñ.
  Nale¿a³o zatem uleniwiæ wyra¿enia przekazywane do wyliczenia.
  
  Najbardziej naturalne by³oby u¿ycie s³owa kluczowego lub funkcji, która uleniwia³aby wyra¿enie.
  Pierwszy pomys³ by³ nie do zrealizowania, poniewa¿ nie mo¿na rozszerzyæ jêzyka C++ o nowe s³owa kluczowe, a standard C++ nie przewidzia³ s³owa kluczowego dla uleniwiania wyra¿eñ.
  Uleniwienie poprzez u¿ycie funkcji mog³oby wygl±daæ nastêpuj±co:
  \begin{lstlisting}[numbers=none,frame=none]
   make_lazy_expression(4 + fibonacci(20));
  \end{lstlisting}
  Jednak semantyka jêzyka C++ równie¿ nie pozwala³a na tak± realizacjê uleniwiania wyra¿eñ, gdy¿ wyra¿enie podane jako argument jest wyliczane przed wywo³aniem funkcji.
  
  Metoda rozwi±zania problemu uleniwiania wyra¿eñ okaza³a siê byæ bardziej skomplikowana i zosta³a zainspirowana przez idiom C++ szablonu wyra¿enia,
  który jako jedna z dobrych praktyk jêzyka C++ zosta³ opisany w ksi±¿ce \textit{More C++ Idioms} \cite{idioms}.
  Implementacja tego szablonu nie by³aby mo¿liwa gdyby nie bardzo silny mechanizm szablonów typów i funkcji w jêzyku C++.

\subsection{Szablony w jêzyku C++}

  Ta sekcja nie zawiera podstawowych informacji na temat szablonów w C++.
  Wprowadzenie do tej tematyki mozna przeczytaæ w ksi±¿ce \cite{c++lang}.
  Moim celem jest pokazanie, dlaczego implementacja przekazywania wyra¿eñ, tak jak tego dokona³em, by³a mo¿liwa.
  
  Szablony s± bardzo silnym mechanizmem. 
  Ciekawostk± jest fakt, ¿e si³a ekspresyjna szablonów nie by³a zamierzona przez twórców w momencie projektowania i mo¿liwo¶ci, które daj±, zosta³y odkryte pó¼niej.
  Szablony C++ s± w rzeczywisto¶ci pewnym funkcyjnym jêzykiem programowania o ekspresywno¶ci rachunku lambda.
  Udowodniono, i¿ mechanizm szablonów jest równowa¿ny maszynie Turinga (\cite{turingcom}).
  W praktyce oznacza to tyle, ¿e szablony C++ pozwalaj± dokonywaæ dowolnych obliczeñ w oparciu o wzorce typów.
  Proszê spojrzeæ na poni¿szy przyk³ad:
  \begin{lstlisting}
template< unsigned n >
struct factorial {
  static const unsigned value = 
    n * factorial<n-1>::value;};
template<>
struct factorial<0> {
  static const unsigned value = 1; };
  \end{lstlisting}
  Wzorzec \verb|factorial| pozwala obliczyæ dowolne warto¶ci silni w czasie kompilacji
  \footnote{Pewnym ograniczeniem jest limit kompilatora na rekurencyjne konkretyzowanie szablonów, ale ten limit mo¿na zmieniæ przy pomocy odpowiednich opcji} i korzystaæ z nich w czasie sta³ym podczas wykonania programu.
  Obliczenie odbywa siê rekurencyjnie, warunkiem koñcz±cym rekurencjê jest \verb|factorial<0>|, które jest specjalizacj± szablonu \verb|factorial|.
  
  
\subsection{Idiom C++ szablonu wyra¿enia}

  Intuicyjnie rzecz ujmuj±c, idiom szablonu wyra¿enia polega na opisaniu wyra¿enia przy pomocy konkretyzacji pewnego szablonu typu.
  Ten typ nie jest nigdy zapisywany w postaci jawnej w programie, gdy¿ mo¿na przypuszczaæ, ¿e sk³adnia szablonu typu by³aby wtedy bardzo nieczytelna.
  Zamiast tego szablon typu jest tworzony w wyniku obliczeñ na typach udostêpnianych przez mechanizm rozwijania szablonów w jêzyku C++.
  Idiom szablonu wyra¿enia wykorzystuje inny idiom Rekurencyjnego Sk³adania Typów (z ang. Recursive Type Composition). 
  Polega on na tym, ¿e szablon typu zawiera pola, których typem jest jest konkretyzjacja tego samego szablonu typów.
  W tym przypadku szablon wyra¿enia mo¿e zawieraæ pola, które s± szablonem wyra¿enia.
  W ten sposób powstaje reprezentacja wyra¿enie w postaci drzewa typów. 
  Taka konstrukcja nazywana jest Abstrakcyjnym Drzewem Syntaktycznym (z ang. Abstract Syntax Tree - AST).
  W li¶ciach drzewa znajduj± siê terminale wyra¿enia, czyli warto¶ci, referencje b±d¼ wska¼niki.
  Natomiast w wêz³ach po¶rednich reprezentowane s± operatory u¿yte w wyra¿eniu, które jako pola posiadaj± szablony wyra¿enia, bêd±ce argumentami operatora.
  Ka¿demu operatorowi odpowiada reprezentuj±cy go szablon typu, z odpowiednio zaimplementowan± funkcj± aplikuj±c± operator, w momencie, gdy szablon wyra¿enia jest wyliczany.
  
  Zaprezentujê ideê szablonu wyra¿enia na przyk³adzie, w którym jedyn± dozwolon± operacj± bêdzie dodawanie liczb ca³kowitych lub zmiennoprzecinkowych.
\begin{lstlisting}
/*** TYPY ODPOWIEDZIALNE ZA BUDOWÊ DRZEWA AST ***/

template <typename T> struct Exp;

template <typename T>
struct Term : Exp<Term<T> >
{
  Term(T v) : val(v){}
  const T val;
};

/* Definicje wez³ów reprezentuj±cych operatory */

template <typename T1, typename T2>
struct Sum : Exp<Sum<T1, T2> >
{
  Sum (T1 l, T2 r) : lhs(l), rhs(r) {}
  const T1 lhs;
  const T2 rhs;
};

template <typename T1, typename T2>
struct Mul: Exp<Mul<T1, T2> >
{
  Mul(T1 l, T2 r) : lhs(l), rhs(r) {}
  const T1 lhs;
  const T2 rhs;
};

/* Wzorzec Infer s³u¿y do obliczania typu wynikowego wyra¿enia */

template <typename E> 
struct Infer {
  typedef E type ; 
};

template <typename T>
struct Infer<Term<T> >
{
  typedef T type;
};

/* Wnioskowanie dla sumy zgodnie z semantyk± jêzyka C++ */

template < >
struct Infer< Sum<double,double> > 
{ 
  typedef double type; 
};

template < >
struct Infer< Sum<double,int> > 
{
  typedef double type;
};

template < > 
struct Infer< Sum<int,double> > 
{
  typedef double type; 
};

template < > 
struct Infer< Sum<int,int> > 
{ 
  typedef int    type;
};

/* Typ(T1 + T2) to typ sumy(typ(T1),typ(T2)) */
template <typename T1, typename T2> 
struct Infer < Sum<T1,T2> > {
  typename Infer<T1>::type typedef T1T ;
  typename Infer<T2>::type typedef T2T ;
  typename Infer<Sum<T1T,T2T> >::type typedef type;
} ;

/* Wnioskowanie o typach dla wzorca Mul jest analogiczne */

/* Wzorzec Exp umo¿liwia unikniêcie definicji operatorów
 * w ka¿dym typie reprezentujacym weze³ po¶redni w drzewie AST */
 
template <typename T>
struct Exp
{
  template <typename U>
  inline Sum<T,U> operator + (U u) 
  { 
    /* static_cast jest potrzebny i prawid³owy, 
     * poniewa¿ Exp jedynie obudowuje typ T */
    return Sum<T,U>(static_cast<T>(*this), u); 
  }
  
  template <typename U>
  inline Mul<T,U> operator * (U u)
  {
    return Mul<T,U>(static_cast<T>(*this), u);
  }
};

template <typename T, typename U>
Sum<T,U> operator + (T t, Exp<U> u)
{
  return Sum<T,U>(t, static_cast<U>(u));
}

template <typename T, typename U>
Mul<T,U> operator * (T t, Exp<U> u)
{
  return Mul<T,U>(t, static_cast<U>(u));
}

/*** DEFINICJE FUNKCJI EWALUUJ¡CYCH DRZEWA AST ***/

inline template <typename T>
Infer<T>::type eval(Exp<T> exp)
{
  return eval(static_cast<T>(exp));
}

inline template <typename T>
Infer<Term<T> >::type eval(Term<T> term)
{
  return term.val;
}

inline template <typename T1, typename T2>
Infer<Sum<T1, T2> >::type eval(Sum<T1, T2> sum)
{
  return eval(sum.lhs) + eval(sum.rhs);
}

inline template <typename T1, typename T2>
Infer<Mul<T1, T2> >::type eval(Mul<T1, T2> mul)
{
  return eval(mul.lhs) + eval(sum.rhs);
}

/* Potrzebna jest tak¿e definicja int eval (int) 
 * oraz double eval(double), poniewa¿ nie ma wymogu,
 * aby zawsze te typy proste by³y obudowane w Term. */
 
inline int eval(int i) {return i;}
inline double eval(double d) {return d;}
\end{lstlisting}

  Wzorzec \verb|Term| (linie 6-11) umo¿liwia oznaczenie dowolnej warto¶ci jako li¶cia w drzewie reprezentujacym szablon wyra¿enia.  
  Teoretycznie wszystkie warto¶ci powinny byc oznaczone w ten sposób.
  Jednak jak sie pó¼niej dowiemy identyczne dzia³anie mo¿na uzyskaæ oznaczaj±c tylko niektóre z warto¶ci.
  
  Wzorce \verb|Sum| oraz \verb|Mul| reprezentuj± wez³y po¶rednie w drzewie AST (linie 15-29).
  Ich pierwszy i drugi parametr reprezentuj± odpowiednie podwyra¿enia, bêd±ce argumentami operatora binarnego.
  Najciekawszym zabiegiem u¿ytym w ich definicji jest podanie definicji tego¿ samego wzorca jako argumentu wzorca Exp, bêd±cego klas± bazow± wzorców operatorów.
  Ma to miejsce przyk³adowo w tym fragmencie kodu: \verb|struct Sum : Exp<Sum<T1, T2> >| i jest w pe³ni dozwolone przez sk³adniê jêzyka.
  Dziêki takiemu zabiegowi mo¿na podaæ implementacjê operatorów tylko we wzorcu \verb|Exp|, a nie jest to konieczne we wszystkich innych wzorcach wêz³ów po¶rednich.
  \verb|Sum<T1, T2>| dziedziczy metody przedefiniuj±ce operatory, z tym, ¿e te definicje s± dopasowane do \verb|Sum<T1, T2>|, poniewa¿ s± parametryzowane tym typem.
  
  Kolejna czê¶æ przyk³adu (linie 33-78) to definicja wzorca \verb|Infer|, który oblicza typ wynikowy wyliczenia wyra¿enia, bêdzie on potrzebny do definicji funkcji ewaluuj±cych wyra¿enie.
  Wykorzystywany jest tutaj mechanizm specjalizacji wzorców, który pozwala okre¶liæ typ wynikowy wyra¿enia w zale¿no¶ci od postaci wzorca.
  Ogólnie, podczas definicji wnioskowania o typach nale¿y pamiêtaæ o uwzglêdnieniu wszystkich istotnych specjalizacji wzorca, czyli dla wêz³ów po¶rednich jak \verb|Term|, \verb|Sum|, \verb|Mul|
  oraz wszystkich mo¿liwych typów, które mog± wystapiæ w wêz³ach po¶rednich.
  Jak widaæ implementacja szablonu wzorca wnioskuj±cego o typie wynikowym wyra¿enia jest bardzo d³uga i czasoch³onna (do tego stopnia, ¿e pomin±³em czê¶æ po¶wiêcon± wnioskowaniu typu dla
  wzorca \verb|Mul|, gdy¿ jest ona analogiczna jak czê¶æ dotycz±ca wzorca \verb|Sum|.
  Na koniec sekcji kodu, która tworzy AST (linie 83-99) znajduje siê definicja wzorca \verb|Exp|, który przeci±¿a operatory dla szablonu wyra¿enia.
  
  Kolejna sekcja kodu przyk³adu (linie od 103 do 132) definiuje funkcjê \feval, która s³u¿y do obliczania warto¶ci szablonu wyra¿enia.
  Funkcja \feval przyjmuje jako argument szablon wyra¿enia (albo warto¶æ prost± int lub double), a nastêpnie oblicza jego warto¶æ zgodnie z semantyk± jêzyka C++.
  Typ zwracany przez \feval jest obliczany przy pomocy wzorca \verb|Infer|.
  
\subsubsection{Szablon wyra¿enia w dzia³aniu}
  Zrozumienie kodu szablonu wyra¿enia przedstawionego powy¿ej bêdzie ³atwiejsze po przeanalizowaniu przyk³adów jego dzia³ania.
  We¼my najprostszy mo¿liwy przyk³ad:
  \begin{lstlisting}[numbers=none, frame=none]
   Term(4) + Term(5);
  \end{lstlisting}
  Wyra¿enie dodaje dwie liczby ca³kowitych.
  Szablon wyra¿enia, który je reprezentuje, zostanie stworzony w wyniku obliczeñ na typach i bêdzie wygl±da³ nastêpuj±co:
  \begin{lstlisting}[numbers=none, frame=none]
   Sum<Term<int>,Term<int> >
  \end{lstlisting}
  Ju¿ na bazie tego prostego przyk³adu nasuwa siê kilka ciekawych kwestii do omówienia.
  
  Po pierwsze mo¿na siê zastanowiæ, po co sk³adania jest tak ``przegadana'' oraz czy potrzebne jest pisanie \verb|Term| przy ka¿dej warto¶ci przekazywanej do wyra¿enia.
  Wiadomo na pewno, ¿e co najmniej jedna warto¶æ musi byæ oznaczona jako terminal szablonu wyra¿enia.
  W przeciwnym przypadku, by³oby to zwyk³e wyra¿enie C++, ¿adna z warto¶ci nie zosta³aby uleniwiona i zosta³oby obliczone gorliwie.
  
  Zastanówmy siê, czy poni¿sze wyra¿enie jest poprawne sk³adniowo i je¶li tak, to jaki bêdzie szablon typu, który powstanie.
  \begin{lstlisting}[numbers=none, frame=none]
   Term(4) + 5;
  \end{lstlisting}
  W tym wyra¿eniu mamy do czynienia z operacj± dodawania warto¶ci typu \verb|Term<int>| oraz typu \verb|int|.
  Poniewa¿ \verb|Term<int>| dziedziczy operator dodawania z \verb|Exp<Term<int> >| to zostanie wywo³any operator dodawania zdefinowany w linii 87 przyk³adu.
  Warto zauwa¿yæ, ¿e typ prawego argumentu przeci±¿onego operatora nie jest w ¿aden sposób ograniczony, wiêc zastosowanie typu int jest poprawne.
  W zwi±zku z tym wynikiem budowy drzewa tego wyra¿enia bêdzie \verb|Sum<Term<int>, int>|.
  Pokazuje to, ¿e szablon wyra¿enia zostanie zbudowany poprawnie równie¿ wtedy, gdy nie wszystkie warto¶ci zostan± oznaczone jako terminale.
  Jednak¿e, czê¶æ warto¶ci, a co najmniej jedna musi zostaæ oznaczona, gdy¿ inaczej budowa szablonu wyra¿enia nie zostanie zapocz±tkowana i wyra¿enie nie zostanie uleniwione, a obliczy siê normalnie.
  
  Wa¿nym faktem jest to, ¿e budowa drzewa AST ma miejsce w czasie kompilacji, wiêc budowanie szablonów wyra¿eñ nie nak³ada narzutów na czas wykonania programu.
  Natomiast narzuty podczas ewaluacji uleniwionego wyra¿enia zale¿± od tego w jakim stopniu kompilator zoptymalizowa³ wywo³ania funkcji \feval wyliczaj±cej warto¶æ wyra¿enia poprzez jej rekurencyjne rozwiniêcie w miejscu wykonania.
  W najgorszym przypadku bêdzie mia³o miejsce jedno wywo³anie funkcji dla ka¿dego wêz³a po¶redniego.
  
  Teraz na bardziej zaawansowanym przyk³adzie zbadamy jakie s± zasady decyduj±ce o tym, kiedy dodanie oznaczenia \verb|Term| jest wymagane, aby uleniwienie wyra¿enia dzia³a³o zgodnie z ¿yczeniem programisty.
  Do tej analizy pos³u¿± dwa przyk³ady uleniwionych wyra¿eñ:
  \begin{lstlisting}[frame=none, numbers=none]
   4 + 5 * Term(6); /* (1) */
   
   Term(4) + 5 * 6; /* (2) */
  \end{lstlisting}
  Nale¿y mieæ ¶wiadomo¶æ, ¿e du¿± rolê w procesie budowy drzewa AST odgrywaj± w³asno¶ci operatorów.
  Liczba ich argumentów, priorytety i kierunek wi±zania decyduj± o postaci drzewa, a tym samym o uleniwieniu wyra¿enia.
  
  W pierwszym wyra¿eniu najpierw kompilator zajmie siê podwyra¿eniem \verb|5 * Term(6)|, które da w rezultacie \verb|Mul<int, Term<int> >|.
  Warto odnotowaæ, ¿e tym razem tylko prawy argument operatora binernego by³ typem szablonu wyra¿enia, wiêc zosta³ u¿yty operator zdefinowany w linii 108 przyk³adu.
  W nastepnej kolejno¶ci nast±pi dodawanie 4 oraz wyra¿enia typu \verb|Mul<int, Term<int> >|, co da w wyniku kolejny bardziej rozbudowany szablon wyra¿enia \verb|Sum<int, Mul<int, Term<int> > >|.
  Uda³o siê pokazaæ, ¿e pierwsze z analizowanych wyra¿eñ zachowa siê zgodnie z intencj± programisty, to znaczy ca³e wyra¿enie zostanie uleniwione.
  
  Analogicznie badamy zachowanie wyra¿enia drugiego.
  Na pocz±tku spostrzegamy, ¿e najpierw dojdzie do obliczenia podwyra¿enia \verb|5 * 6|. 
  Zatem ewaluacja odbêdzie siê gorliwie, poniewa¿ budowa szablonu wyra¿enia nie zosta³a zapocz±tkowana, mamy tu do czynienia ze zwyk³ym mno¿eniem.
  W nastêpnym kroku odbêdzie siê dodawanie \verb|Term(4)| i wyniku \verb|5 * 6|, czyli \verb|30|, czego konsekwencj± bêdzie stworzenie szablonu wyra¿enia \verb|Sum<Term<int>, int>|.
  To nie jest to czego oczekiwali¶my, gdy¿ za³o¿yli¶my, ¿e chcemy uleniwiæ ca³e wyra¿enie, a zasz³o to jedynie dla jego czê¶ci.
  
  Wnioskiem z powy¿szej analizy jest regu³a propagacji leniwo¶ci w czasie budowania szablonu wyra¿enia.
  Propagowanie zachodzi od warto¶ci oznaczonej jako terminal w górê drzewa.
  St±d ka¿dy operator na ¶cie¿ce pomiêdzy uleniwionym terminalem, a korzeniem drzewa (w³±cznie) bêdzie uleniwiony, czyli nie bêdzie wywo³any od razu, 
  a zostanie zakodowany w strukturze szablonu wyra¿enia i wywo³any, gdy nast±pi wymuszenie obliczenia wyra¿enia.
  W szczególno¶ci, pisz±c kod tworz±cy szablony wyra¿enia w oparciu o przedstawiony przyk³ad nale¿y mieæ na uwadze to, ¿e tworzenie drzew AST przez kompilator nie jest jednoznaczne,
  poniewa¿ kompilator mo¿e w przypadku wyst±pienia obok siebie operatorów o identycznym priorytecie stworzyæ ró¿ne drzewa AST.
  Przyk³adem jest wyra¿enie \verb|4 + 5 + 6|.
  
\subsection{Praktyczna implementacja szablonu wyra¿enia -- Boost Proto}

  Przedstawiony powy¿ej sposób da siê uogólniæ dla dowolnego wyra¿enia w jêzyku C++.
  To znaczy, ¿e stworzenie dowolnego leniwego wyra¿enia jest mo¿liwe, do czego d±¿y³em podczas tworzenia implementacji Parallel.
  Jednak¿e napisanie takiej biblioteki od podstaw wykracza³o poza ramy tej pracy magisterskiej.
  Dlatego siêgn±³em po rozwi±zania ju¿ istniej±ce, publicznie dostepne i sprawdzone.
  W celu implementacji uleniwionych wyra¿eñ metod± szablonów wyra¿eñ wybra³em bibliotekê Boost Proto.
  
  Boost Proto jest bibliotek± s³u¿±c± do tworzenia Wbudowanych Jêzyków Domenowych (z ang. Domain Specific Embedded Language) w jêzyku C++. 
  Zawiera narzêdzia do tworzenia, sprawdzania typów, przetwarzania oraz ewaluacji szablonów wyra¿eñ. Proto zapewnia:
  \begin{itemize}
   \item Szablony wyra¿eñ w postaci AST
   \item Mechanizm modyfikacji zachowania wyra¿eñ
   \item Przeci±¿anie operatorów dla budowy AST z wyra¿enia
   \item Narzêdzia do definiowania gramatyki wyra¿eñ
   \item Rozszerzalny mechanizm wyliczenia szablonu wyra¿enia
   \item Rozszerzalny zestaw operacji przetwarzania szablonów wyra¿eñ
  \end{itemize}

  Biblioteka Boost Proto zosta³a wykorzystana do implementacji nastêpuj±cych komponentów biblioteki Parallel:
  \begin{itemize}
   \item Funkcje do oznaczania terminali:
   \begin{itemize}
    \item \verb|val| -- funkcja przekazuj±ca terminal do wyra¿enia przez warto¶æ
    \item \verb|cval| -- funkcja przekazuj±ca terminal do wyra¿enie przez warto¶æ sta³±
    \item \verb|ref| -- funkcja przekazuj±ca terminal do wyra¿enia przez referencjê
    \item \verb|cref| -- funkcja przekazuj±ca terminal do wyra¿enia przez referencjê sta³±
   \end{itemize}
   \item \verb|lazyf| -- funkcja s³u¿±ca do tworzenia uleniwionego wywo³ania funkcji
   \item \verb|deferred_expr| -- szablon typu przechowuj±cego uleniwione wyra¿enia i zarz±dzaj±cego jego wyliczeniem
  \end{itemize}
  
  Biblioteka Parallel korzysta z Boost Proto do tworzenia szablonów wyra¿eñ w postaci AST, równie¿ przy pomocy mechanizmu przeci±¿ania operatorów, dziêki czemu budowa AST jest uproszczona.
  Ponadto ewaluacja odbywa siê przy pomocy dostarczonej przez Boost Proto funkcji \verb|proto::eval| z domy¶lnym zachowaniem.
  Zasada dzia³ania Boost Proto jest analogiczna do dzia³ania przyk³adu pokazanego powy¿ej.

\subsection{Alternatywne rozwi±zanie}

  Do wyboru by³a równie¿ inna mo¿liwo¶æ realizacji przekazywania wyra¿enia ni¿ forma uleniwiona opisana to powy¿ej.
  Podobny efekt mo¿na uzyskaæ stosuj±c obiekty funkcyjne, które reprezentowa³yby dane wyra¿enie.
  Istnieje jednak istotny powód, dla którego zosta³o wybrane pierwsze z przedstawionych rozwi±zañ.
  Leniwe wyra¿enia maj± bardziej intuicyjn± sk³adniê, natomiast tworzenie odpowiednich obiektów funkcyjnych wymaga znajomo¶ci stosownych bibliotek.
  Przyk³adami s± Boost.Lambda, Boost.Function i Boost.Bind, jednak¿e pomimo tego, ¿e s± to jedne z najlepszych bibliotek w swojej klasie, w przypadku pisania rozbudowanego wyra¿enia ich sk³adnia jest zdecydowanie nieintuicyjna.
  Szczególnie problematyczny jest zapis zagnie¿d¿onych funkcji, w tym operatorów.
  Nastêpuj±cy kawa³ek kodu nie nale¿y do czytelnych:
\begin{verbatim}
  bind(f, bind(operator+,4, (bind(operator*, 5, 6)))); //f(4 + 5 * 6)
\end{verbatim}
  Zamiast bardziej intuicyjnego:
\begin{verbatim}
  lazyf(val(4) + val(5) * val(6));
\end{verbatim}
  Tak naprawdê wystarczy³oby
\begin{verbatim}
 lazyf(f, 4 + val(5)*6);
\end{verbatim}
  gdy¿ \verb|val(5)| wprowadzi³oby leniwo¶æ na najni¿szym poziomie w drzewie wyra¿enia, która nastêpnie propagowa³aby siê w górê drzewa.

  Dlatego, ze wzglêdu na znacznie bardziej intuicyjn± sk³adniê, wybrano leniwe wyra¿enia do realizacji przekazywania obliczeñ do wykonania równoleg³ego.

\section{Implementacja mechanizmu ewaluacji}\label{s:ewaluacja}

  Zarys mechanizmu ewaluacji zosta³ przedstawiony w sekcji \nameref{ss:wykonywanie}.
  G³ówn± funkcj± mechanizmu ewaluacji jest pobieranie zadañ (wyra¿eñ do obliczenia) zlecanych przez kod programu i ich ewaluacja.
  Do implementacji tej czê¶ci biblioteki wykorzystano wzorzec projektowy puli w±tków oraz kolejki zadañ.
  G³ówn± klas± tej czê¶ci biblioteki jest \verb|evaluation_mgr| (od ang. evaluation manager -- mened¿er ewaluacji), która jest singletonem i zarz±dza ca³o¶ci± procesu wykonywania zadañ.
  
\subsection{Zadania w bibliotece Parallel}

  Zadaniem w kontek¶cie biblioteki Parallel nazywam uleniwione wyra¿enie, które zosta³o przekazane bibliotece do obliczenia.
  Zadanie jest reprezentowane przez konkretyzacjê wzorca typu \verb|deferred_expr| (od ang. deferred expression -- wyra¿enie odroczone).
  Jedyny konstruktor publiczny tego wzorca przyjmuje jako argument szablon wyra¿enia, taki jaki zosta³ opisany w sekcji \nameref{s:przekazywanie_wyrazen}.
  Szablon wyra¿enia jest przechowywany jako jedno z pól \verb|deferred_expr| i poddawany ewaluacji po wywo³aniu metody \verb|evaluate|.
  Pozosta³e pola i metody \verb|deferred_expr| s³u¿a kontrolowaniu wyliczenia wyra¿enia oraz przekazywaniem wyniku do skojarzonego obiektu typu \verb|deferred_value|
  \footnote{Zgodnie z opisem z \nameref{ss:operacje} obiekt \dexp jest skojarzony 1-1 z obiektem \dval.}.
  
\subsection{Pula w±tków}

  Wzorzec puli w±tków zosta³ wybrany ze wzglêdu na efektywno¶æ.
  Dziêki takiej implementacji unika siê tworzenia w±tku dla ka¿dego zadania do wykonania, co jest operacj± dosyæ drog± i warto zadbaæ, aby nie by³a wykonywana zbyt czêsto.
  Ka¿dy z w±tków dzia³a w nieskoñczonej pêtli w funkcji \verb|eval_loop|, w której w±tek próbuje pobraæ zadanie do wykonania z kolejki zadañ, a je¶li nie jest ono dostêpne to czeka na zmiennej warunkowej.
  Do implementacji zosta³a wykorzystana biblioteka Boost.Threads.
  
  Pula w±tków pozwala unikn±æ innego problemu zwi±zanego z tworzeniem w±tku dla ka¿dego zadania.
  W przypadku gdyby pojawi³o siê zbyt wiele zadañ jednocze¶nie liczba w±tków mog³aby wzrosn±æ do takiej liczby, ¿e wydajno¶æ programu znacznie by spad³a z powodu czêstego prze³±czania kontekstu pomiêdzy ró¿nymi w±tkami.
  Pula w±tków pozwala ustaliæ maksymaln± liczbê w±tków, co przedziwdzia³a przeci±¿eniu systemu.
  Obecnie liczba w±tków jest ustalana przez programistê, nic nie stoi na przeszkodzie, aby w przysz³o¶ci liczba w±tków by³a dobierana automatycznie w zale¿no¶ci od wydajno¶ci systemu b±d¼ innych parametrów.
  
\subsection{Kolejka zadañ}

  Kolejka zadañ jest standardow± kolejk± FIFO przechowuj±c± obiekty \dexp.
  Poniewa¿ jednocze¶nie kod programu lub ka¿dy z w±tków z puli przechowywanej w \verb|evaluation_mgr| mo¿e chcieæ skorzystaæ z kolejki, dostêp do niej jest chroniony sekcj± krytyczn±.
  Dodawanie zadañ do kolejki odbywa siê w ciele funkcji \feval przy u¿yciu funkcji \verb|add_for_eval|.

\subsection{Procedura ewaluacji}

  Procedura ewaluacji z punktu widzenia mechanizmu ewaluacji wygl±da bardzo prosto.
  W±tek-robotnik pobrawszy zadanie wywo³uje jego metodê \verb|evaluate|.
  To skutkuje wyliczeniem wyra¿enia, a je¶li typ wynikowy wyra¿enia jest inny ni¿ \verb|void| to warto¶æ zostaje przekazana do skojarzonego obiektu \dval.
  Po wyliczeniu wyra¿enia obiekt \dexp jest niszczony, gdy¿ nie jest ju¿ potrzebny.
  
  Ten obraz komplikuje siê, gdy rozwa¿ymy pewien bardzo istotny scenariusz.
  Otó¿ nie ma problemu je¶li, w±tki-robotnicy dokonuj± ewaluacji zadañ z kolejki odpowiednio szybko.
  Jednak, gdy d³ugo¶æ kolejki wzro¶nie mo¿e doj¶æ do tego, ¿e w±tek programu, który zleci³ wyliczenie wyra¿enia oczekuj±cego w kolejce, bêdzie potrzebowa³ jego wyniku.
  Wtedy nast±pi próba pobrania warto¶ci z obiektu \dval, który jeszcze nie otrzyma³ obliczonej warto¶ci.
  To oznacza, ¿e w±tek programu musia³by zawiesiæ wykonywanie i poczekaæ, a¿ warto¶æ zostanie obliczona.
  
  Gdy w±tek programu oczekuje na wyra¿enie, którego ewaluacja ju¿ siê rozpoczê³a, to nie ma innego wyj¶cia ni¿ poczekanie na dokoñczenie obliczeñ.
  Jednak, gdy zadanie, na które program oczekuje, jeszcze nie zosta³o pobrane do wykonania dosz³oby do absurdalnej sytuacji, 
  poniewa¿ program zawiesi³by siê i czeka³by na wykonanie zadania, podczas gdy sam móg³by wykonaæ potrzebne obliczenia.
  Odpowienio zaimplementowana procedura ewaluacji uwzglêdnia ten problem.
  
  W analogicznej sytuacji w±tek programu, gdy zorientuje siê, ¿e wyra¿enie nie zosta³o obliczone sam dokona ewaluacji.
  Zostanie wywo³ana ta sama procedura \verb|evaluate|, któr± wywo³uj± w±tki-robotnicy.
  Mo¿e to skutkowaæ zdublowanym wyliczeniem wyra¿enia, w przypadku, gdy zarówno w±tek programu, jak i jeden z w±tków-robotników obliczyliby wyra¿enie.
  Taka sytuacja by³aby niedopuszczalna, poniewa¿ wykonywanie wyra¿enia w C++ nie jest idempotentne z powodu efektów ubocznych.
  
  Najbardziej standardowym rozwi±zaniem by³oby umieszczenie w ka¿dym obiekcie \dexp flagi wraz mutexem j± chroni±cym w celu zapobie¿enia podwójnej ewaluacji wyra¿enia.
  Jednak¿e umieszczenie mutex-a w ka¿dym obiekcie ma pewien narzut pamiêciowy i wydajno¶ciowy.
  
  Istnieje lepsze rozwi±zanie tego problemu wykorzystuj±ce funkcjê z biblioteki Boost Threads \verb|call_once| gwarantuj±c± jednokrotne wywo³anie pewnej instrukcji.
  Przekazanie tej funkcji zmiennej typu \verb|once_flag| wraz z funkcj± do wykonania (w tym przypadku funkcj± \verb|deferred_expr::evaluate|) sprawia, ¿e dla danej flagi funkcja wykona siê tylko raz.
  Wywo³anie \verb|call_once| z ju¿ raz wykorzystan± flag± \verb|once_flag| zakoñczy siê natychmiast bez wywo³ania przekazanej funkcji.
  Poniewa¿ typ \verb|once_flag| ma niewielki rozmiar (na wiêkszo¶ci platform jest to typ \verb|long|) to umieszczenie go jako pola ka¿dego obiektu \dexp dodaje mniejszy narzut pamiêciowy ni¿ stosowanie mutexów.
  
  Innym wa¿nym aspektem procedury ewaluacji odroczonego wyra¿enia jest obs³uga wyj±tków.
  Zgodnie z koncepcj± biblioteki wyj±tki, które wyst±pi± podczas ewaluacji wyra¿enia (w ciele funkcji \verb|evaluate| s± wywo³ywane, a nastêpnie przekazywane do obiektu \dval zamiast wyniku.
  Dziêki temu wyj±tek bêdzie móg³ zostaæ przekazany z obiektu \dval do g³ównego w±tku programu.
  
\subsection{Ograniczenia mechanizmu ewaluacji}

  W zwi±zku ze sposobem przekazywania wyra¿eñ do obliczenia, mo¿liwo¶ci projektowania mechanizmu ewaluacji by³y do¶æ powa¿nie ograniczone.
  W ogólno¶ci mogliby¶my wyobraziæ sobie sytuacjê, w której wyra¿enie z programu dzia³aj±cego na jednym komputerze by³oby przekazywane do wyliczenia do innych programów lub nawet do innych komputerów, w celu wiêkszego rozproszenia i jeszcze lepszego zrównoleglenia wykonania programu.
  W przypadku biblioteki parallel wyst±pi³o kilka ograniczeñ, które uniemo¿liwi³y zaprojektowanie ogólniejszego mechanizmu obliczeñ.
  
  Migracja kodu (taka jak zosta³± opisana w ksi±¿ce \cite{dissys}) nie jest wspierana przez jêzyk C++, poniewa¿ kod kompilowany jest do natywnego kodu maszynowego, a nie kodu po¶redniego.
  Nie ma mo¿liwo¶ci zserializowania fragmentu obliczeñ i przes³ania do wykonania na innym komputerze, o nieznanej architekturze.
  W przeciwieñstwie do jêzyka C++ to jest wykonalne w jêzyku Java.
  
  Alternatyw± dla wsparcia jêzyka dla migracji kodu jest rozszerzenie biblioteki o narzêdzia automatycznie generuj±ce kod dla klienta (programu zlecaj±cego obliczenia) i serwera (programu wykonuj±cego obliczenia).
  To przypomina metodê tworzenia RPC i rodzi szereg innych problemów równie¿ opisanych w \cite{dissys}.
  Implementacja takiego modelu prowadzenia obliczeñ w bibliotece Parallel wykracza³aby poza ramy nakre¶lonej pracy oraz mog³aby ograniczyæ u¿yteczno¶æ biblioteki ze wzglêdu na bardziej skomplikowany proces programowania i kompilacji.
  
  Kolejne z ograniczeñ jest zwi±zane z obecno¶ci± w wyra¿eniu przekazywanym do obliczenia warto¶ci typu referencje lub wska¼niki, które s± ¶ci¶le zale¿ne od przestrzeni adresowej programu. 
  Przes³anie ich nawet do innego programu na tym samym komputerze wymaga³oby wykorzystania specjalnej procedury, gdy¿ proste przekazanie warto¶ci tego typu powodowa³oby b³êdy w dostêpie do pamiêci.
  Obej¶cie tego problemu oferuje mechanizm pamiêci wspó³dzielonej, ale powoduje znaczny narzut zwi±zany z dostêpnem do tego rodzaju pamiêci.
 
  Wymienione powy¿ej ograniczenia uzasadniaj± podjêcie decyzji o przyjêciu dla biblioteki Parallel mechanizmu ewaluacji wyra¿eñ opartego o w±tki.

\section{Implementacja zwracania wyniku obliczeñ}
  
  Mo¿liwo¶æ zwracania wyników z obliczeñ wykonywanych przez inny w±tek jest jedn± z najwa¿niejszych cech przemawiaj±cych na korzy¶æ biblioteki Parallel w porównaniu do standardowych bibliotek oferuj±cych wielow±tkowo¶æ.
  Najwa¿niejszym elementem procesu zwracania wyników przez bibliotekê Parallel jest wzorzec typu \dval parametryzowany typem wyniku wyra¿enia.
  Obiekty tego typu s± po¶rednikami, które przekazuj± informacje z kodu biblioteki do kodu programu.
  
\subsection{Podstawowe w³a¶ciwo¶ci wzorca typu \dval}

\subsubsection{Przekazanie warto¶ci}

  Obiekt typu \dval po utworzeniu i zwróceniu przez funkcjê \feval posiadaj± warto¶æ nieokre¶lon±.
  Dopiero po obliczeniu wyra¿enia zapamiêtanego w skojarzonym obiekcie \dexp, otrzymana warto¶æ jest przekazywana do obiektu \dval w celu jej zapamiêtania.
  Poniewa¿ obiekt \dexp jako jedyny ma prawo dokonania takiego przypisania, nie jest konieczna ochrona przed wspó³bie¿nym zapisem do obiektu \dval.
  
\subsubsection{Wymuszenie wyliczenia wyra¿enia}

  Obiekt typu \dval pozwala na kontrolowanie w pewnym stopniu wyliczenia wyra¿enia przez programistê.
  Mianowicie, wywo³anie metody \verb|force| powoduje wymuszenie wyliczenia wyra¿enia.
  Zatem programista w razie takiej potrzeby mo¿e uzyskaæ pewno¶æ, ¿e ewaluacja wyra¿enia zosta³a zakoñczona.
  Ponadto, do wymuszenia wyliczenia wyra¿enia zawsze dochodzi wtedy, gdy pobierana jest warto¶æ wyra¿enia.
 
\subsubsection{Pobranie warto¶ci}

  Obiekt typu \dval pozwala na pobranie warto¶ci poprzez wywo³anie metody \verb|get_value| lub te¿ niejawnie, poniewa¿ poprzez operator konwersji do typu, który reprezentuje.
  Zatem taki ci±g instrukcji:
  \begin{lstlisting}[numbers=none, frame=none]
   deferred_value<int> d = parallel::eval(parallel::val(4) + 5);
   /* ... */
   int c = d + 42;
  \end{lstlisting}
  jest poprawny syntaktycznie.
  Zatem obiektu typu wzorcowego \dval mo¿na u¿yæ w ka¿dym miejscu, gdzie dozwolone jest u¿ycie typu wynikowego wyra¿enia.
  Skutkuje to wywo³aniem operatora konwersji i pobraniem warto¶ci.
 
  Alternatywnym sposobem definicji wzorca \dval by³o nie umieszczanie w jego interfejsie operatora konwersji.
  Uniemo¿liwi³oby to stosowanie obiektów typu \dval w miejsce typu wynikowego wyra¿enia, co sprawi³oby, ¿e pobieranie warto¶ci sta³oby siê operacj± zawsze wywo³ywan± jawnie przez programistê.
  W trakcie projektowania interfejsu biblioteki podjêto decyzjê o umieszczeniu operatora konwersji, poniewa¿ czyni to sk³adniê bardziej naturaln±.
  Ponadto u¿ywanie obiektów typu \dval w wyra¿eniach bez jawnego pobierania warto¶ci ma bardzo istotne znaczenie dla pe³nego wykorzystania funkcji przeci±¿aj±cych operatory dla wzorca typu \dval.
  Ta kwestia zostanie wyja¶niona w nastêpnej sekcji.
  
\subsection{Przeci±¿±nie operatorów szablonu typu \dval}

\subsubsection{Motywacja dla przeci±¿ania operatorów}

  Mo¿na wyobraziæ sobie scenariusz, w którym chc±c skorzystaæ z warto¶ci przechowywanej w zmiennej typu \dval, 
  programista zawsze wywo³ywa³by jawn± metodê pobrania warto¶ci b±d¼ stosowa³by niejawn± metodê, przy u¿yciu operatora konwersji.
  Wygl±da³oby to w kodzie w sposób nastêpuj±cy.
  Wersja z jawnym pobraniem warto¶ci:
  \begin{lstlisting}[numbers=none, frame=none]
    deferred_value<int> d = parallel::eval(parallel::val(4) + 5);
    /* ... */
    auto c = d.get_value() + 42;
   \end{lstlisting}
   Wersja z niejawnym pobraniem warto¶ci:
   \begin{lstlisting}[numbers=none, frame=none]
    deferred_value<int> d = parallel::eval(parallel::val(4) + 5);
    /* ... */
    auto c = d + 42;
   \end{lstlisting}
   
   Zanim przejdziemy do dalszej czê¶ci rozwa¿añ bardzo wa¿ne jest przypomnienie motywacji stosowania biblioteki Parallel.
   Mianowicie celem programisty u¿ywaj±cego biblioteki jest zrównoleglenie \underline{jak najwiêkszej} czê¶ci obliczeñ.
   Podkre¶li³em s³owa ``jak najwiêkszej'', poniewa¿ im wiêksza czê¶æ obliczeñ zostanie wykonana przez w±tki biblioteki Parallel, tym potencjalnie szybciej mo¿e dzia³aæ program.
   Natomiast, tym wiêksza bêdzie czê¶æ obliczeñ wykonana przez bibliotekê Parallel, im pó¼niej bêdzie wymuszane pobranie warto¶ci z obiektów \dval.
   
   W jawnym przypadku wszystko jest jasne, biblioteka nie ma pola manewru, gdy¿ programista za¿±da³ pobrania warto¶ci, wiêc warto¶æ musi zostaæ policzona i zwrócona przez metodê \verb|get_value|.
   Czy podobnie jest w drugim przypadku?
   Czy zmienna \verb|c| musi zostaæ oznaczona jako typ \verb|int| i powinna zostaæ do niej natychmiast przypisana warto¶æ 51?
   By³oby to poprawne, ale nie jest to konieczne.
   
   Z punktu widzenia zwiêkszania efektywno¶ci wykorzystania biblioteki Parallel lepiej bêdzie, gdy obliczenie warto¶ci wyra¿enia skojarzonego z obiektem \verb|d| nie bêdzie w tej sytuacji wymuszone,
   gdy¿ mo¿e zostaæ odroczone.
   Aby to uzyskaæ wystarczy przeci±¿yæ operator dodawania, w taki sposób, 
   aby wyra¿enie \verb|d + 42| zwraca³o warto¶æ odroczon±, zawieraj±c± uleniwione wyra¿enie w postaci szablonu wyra¿enia.
   Dzia³anie g³ównego w±tku programu mog³oby siê wtedy toczyæ dalej bez wymuszania obliczenia warto¶ci \verb|d|,
   natomiast pó¼niej gdy zostanie wymuszone obliczenie warto¶ci \verb|c| to rekurencyjnie zostanie wymuszone równie¿ wyliczenie \verb|d|, w celu ewaluacji szablonu wyra¿enia zapisanego w \verb|c|.
   
\subsubsection{Implementacja przeci±¿ania operatorów}

  Jêzyk C++ pozwala na przeci±¿enie wszystkich operatorów, oprócz \verb|::|, \verb|.| oraz \verb|.*|.
  Przecie¿anie operatorów dla obiektów \dval ma sens dla zdecydowanej wiêkszo¶ci, ale nie dla wszystkich operatorów.
  Za bezcelowo uznano przeci±¿anie operatorów \verb|->*| i \verb|->|.
  Przedefiniowanie operatorów \verb|new|, \verb|new []|, \verb|delete| oraz \verb|delete []| nie by³o potrzebne.
  Ponadto domy¶lne zachowanie operatora \verb|,| jest odpowiednie dla typu \dval.
  Pozosta³e operatory zosta³y przedefinowane w taki sposób, aby uzyskaæ taki efekt, ¿e obiektów \dval mo¿na u¿ywaæ wszêdzie tam, gdzie mo¿na u¿yæ typu, który dany obiekt \dval reprezentuje.
  Przedefinowania operatorów zwracaj± jako wynik obiekty \dval, z szablonem wyra¿enia, obliczenie którego pozwoli uzyskaæ po¿±dany wynik.
  Oto pe³na lista przeci±¿onych operatorów:
  \begin{verbatim}
   +  -  *  /  %  ^  &  |  ~  !  =  <  >  <<   >>  +=  -=  *=  /=  %=  ^=  
   &=  |=  >>=  <<=  ==  !=  <=  >=  &&   ||  ++  --  []  ()
  \end{verbatim}

  Dla ilustracji sposobu implementacji funkcji przeci±¿aj±cych operatory dla obiektów \dval pos³u¿ê siê przyk³adem przeci±¿enia dodawania:
  \begin{lstlisting}
   inline deferred_value<T> operator + (T& rhs)
      { return make_deferred_value_from_exp(lazyf(&deferred_value<T>::get_value, this) + rhs); }
  \end{lstlisting}
  
  W funkcji przeci±¿aj±cej operator tworzona jest inna ni¿ znana do tej pory wersja obiektu \dval.
  Nie jest zwracana przez funkcjê \feval, a przez \verb|make_deferred_value_from_exp|, do której przekazywany jest szablon wyra¿enia.
  W tym przypadku tworzony jest szablon wyra¿enia, w którym funkcja \verb |get_value| jest uleniwiona i do wyniku jej wywo³ania dodawany jest drugi argument dodawania.
  Pozwala to na uzyskanie oczekiwanego zachowania, o którym by³a mowa powy¿ej.

%   \begin{lstlisting}
%   template <typename T>
%   class deferred_value
%   {
%     /* ... */
%     inline template <typename U>
%     typename deferred_value<
%       proto::result_of::make_expr<
% 	proto::tag::add,
% 	T,
% 	U>::type const> operator + (U u)
%     {
%       return deferred_value(proto::make_expr<proto::tag::plus>(*this, u));
%     }
%     
%     inline template <typename U>
%     typename deferred_value<
%       proto::result_of::make_expr<
% 	proto::tag::assign,
% 	deferred_value<T>,
% 	U>::type const>& operator = (const U& u)
%     {
%       if (this != &u)
%       {
% 	return deferred_value(proto::make_expr<proto::tag::assign>(*this, u));
%       }
%     }
%   };	
%   \end{lstlisting}
  
\subsection{Szczególne postacie warto¶ci zwracanych przez wyra¿enie}

  Niektóre z postaci wyra¿eñ przekazywanych do obliczenia posiadaj± typ wynikowy, który wymaga specjalnego traktowania, poniewa¿ domy¶lny wzorzec typu \dval nie zadzia³a³by w ich przypadku.
  Poni¿ej znajduje siê opis takich przypadków wraz z prezentacj± rozwi±zania zastosowanego w implementacji biblioteki Parallel.

\subsubsection{Wyra¿enie zwracaj±ce typ \texttt{void}}
  
  Mo¿e siê zdarzyæ, ¿e typem wynikowym wyra¿enia jest typ \verb|void|.
  Nie mo¿na wtedy mówiæ o warto¶ci, któr± wyra¿enie zwraca, nie mo¿na równie¿ zadeklarowaæ zmiennej typu void.
  Dlatego obiekt typu \dval, dla którego typem zwracanym jest typ \verb|void|, powinien byæ zaimplementowany inaczej.
  Dla poradzenia sobie z tym przypadkiem powsta³a odpowiednia specjalizacja wzorca \dval.
  Nie posiada ona ¿adnej warto¶ci, któr± mo¿na by³oby pobraæ ani s³u¿±cych do tego metod.
  
  W tym przypadku rozwa¿a³em ca³kowit± rezygnacjê ze zwracania obiektu typu \dval z funkcji \feval.
  Istnieje jednak bardzo wa¿ny scenariusz, w którym konkretyzacja wzorca \dval sparametryzowana typem \verb|void| jest niezbêdna.
  Ilustruje to poni¿szy przyk³ad:
  \begin{lstlisting}
  #include <parallel.h>
  
  int main()
  {
    /* Array initialized with some numbers */
    std::vector a = { ... }; 
    auto d = parallel::eval(lazyf(sort<int*>, a.begin(), a.end()));
    /* Do something without using a */
    d.force();
    for_each(a.begin(), a.end(), process_a);
  }
  \end{lstlisting}
  Po zleceniu równoleg³ego posortowania tablicy \verb|a| kod mo¿e wykonywaæ czynno¶ci niekorzystaj±ce z warto¶ci zapisanych w tablicy.
  Ale w momencie, gdy dochodzi do przetwarzania \verb|a| programista musi uzyskaæ pewno¶æ, ¿e sortowanie siê zakoñczy³o.
  Wystarczy zatem, ¿e wywo³± metodê \verb|force| na obiekcie \dval, która wymusi wykonanie sortowania, je¶li nie zosta³o rozpoczête i poczeka do jego zakoñczenia.
  Po powrocie z \verb|force| programista mo¿e u¿ywaæ elementów tablicy \verb|a|, maj±c pewno¶æ, ¿e s± posortowane.
  
\subsubsection{Wyra¿enie zwracaj±ce referencjê}

  Równie¿ zwracanie referencji do zmiennej jako wyniku obliczenia wyra¿enia okaza³o siê problematyczne.
  Przyk³adem takiego wyra¿enia jest:
  \begin{lstlisting}[numbers=none, frame=none]
   /* using namespace std, parallel; */
   eval(ref(cout) << "Operacja zakoñczona sukcesem." << endl);
  \end{lstlisting}

  W tym przypadku problemem jest inicjalizacja sk³adowej \verb|m_value| wzorca typu \dval , którego zadaniem jest przechowywanie zwracanej warto¶ci.
  W przyk³adzie typ zwracany to \verb|ostream&|.
  Referencja mo¿e byæ zainicjalizowana wy³±cznie w li¶cie inicjalizacyjnej konstruktora obiektu.
  Poniewa¿ obiekt, do którego mia³aby siê odnosiæ referencja z obiektu \dval jeszcze nie zosta³ obliczony to w konstruktorze nie mo¿na ustawiæ tej referencji.
  St±d zastosowanie typu identycznego z typem wynikowym wyra¿enia zwracaj±cego referencjê nie jest mo¿liwe.
  Konieczne by³o stworzenie odpowiedniej specjalizacji wzorca \dval.
  
  Nale¿y wykluczyæ rozwi±zanie polegaj±ce na skopiowaniu warto¶ci obiektu.
  Zmieni³oby to semantykê wyra¿enia i ograniczy³oby mo¿liwo¶æ u¿ywania Parallel dla wyra¿eñ zwracaj±cych obiekty niekopiowalne.
  
  Istnieje w¶ród programistów jêzyka C++ przekonanie, i¿ referencja jest \textit{de facto} wska¼nikiem, ale z ³adniejsz± sk³±dni±.
  Pomimo, ¿e to stwierdzenie nie jest prawdziwe, poniewa¿ istniej± pewne subtelne ró¿nice w semantyce wska¼ników i referencji, 
  to rozwi±zanie problemu ze zwracaniem referencji zainspirowane tym stwierdzeniem ¶wietnie sprawdzi³o siê w praktyce.
  Wska¼niki C++ maj± bowiem tak± istotn± ró¿nice w stosunku do referencji, ¿e mo¿na je przestawiæ na inny obiekt, wiêc nie musz± byæ inicjalizowane w konstruktorze.
  St±d sk³adowa \dval, która przechowuje wynik obliczenia wyra¿enia jest wska¼nikiem, natomiast wyspecjalizowany dla opisywanego przypadku wzorzec \dval udostêpnia interfejs, który emuluje referencjê.
  
\subsection{Obs³uga wyj±tków}

  Jednym z za³o¿eñ biblioteki Parallel by³o umo¿liwienie niezawodnej obs³ugi sytuacji wyj±tkowych, które mog± siê zdarzyæ podczas wykonywania zleconych obliczeñ.
  Gdy zostaje wy³apany wyj±tek jest on przekazywany do odpowiedniego obiektu \dval, gdzie zostaje zapamiêtany.
  Natomiast w przypadku wymuszenia obliczenia warto¶ci obiektu \dval, w którym zapamiêtano wyj±tek, jest on ponownie rzucany i powinien zostaæ przechwycony oraz obs³u¿ony w kodzie programu.
  



