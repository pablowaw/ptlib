\chapter{Ewaluacja biblioteki}\label{r:ewaluacja}

  Ewaluacja biblioteki mia³a na celu weryfikacjê poprawno¶ci dzia³ania biblioteki oraz przetestowanie wzrostu wydajno¶ci programów jej u¿ywaj±cych.
  Poszczególne etapy weryfikacji zosta³y opisane w odpowiednich sekcjach tego rozdzia³u.

\section{Testy poprawno¶ci}

  Testy dotycz±ce poprawno¶ci biblioteki Parallel zosta³y przeprowadzone przy wykorzystaniu narzêdzia do przeprowadzania testów Boost Unit Test Framework.
  Testy te koncentrowa³y siê na sprawdzeniu czy wyniki wyra¿eñ obliczanych przez bibliotekê Parallel s± identyczne z oczekiwanymi oraz czy podczas ich obliczania nie wystêpuj± niespodziewane b³êdy.
  Wyodrêbnione zosta³y nastêpuj±ce przypadki u¿ycia biblioteki Parallel, definowane przez ró¿ne typy wyra¿eñ przekazywanych do obliczenia, dla których zosta³y zaimplementowane odpowiednie testy jednostkowe (z ang. unit test):
  \begin{itemize}
   \item wyra¿enie z ró¿nymi rodzajami typów:
    \begin{itemize}
     \item wyra¿enie z typami prostymi,
     \item wyra¿enie zawierajace obiekty z³o¿one.
    \end{itemize}
   \item wyra¿enia z ró¿nymi formami przekazywania zmiennych:
    \begin{itemize}
     \item zmienna przekazywane przez warto¶æ,
     \item zmienna przekazywana przez referencjê,
     \item zmienna przekazywana przez wska¼nik.
    \end{itemize}
   \item wyra¿enia z ró¿nymi rodzajami typów zwracanych:
    \begin{itemize}
     \item wyra¿enie o typie wynikowym \verb|void|,
     \item wyra¿enie zwracaj±ce typ prosty,
     \item wyra¿enie zwracaj±ce typ z³o¿ony,
     \item wyra¿enie zwracaj±ce referencjê,
     \item wyra¿enie zwracaj±ce wska¼nik,
     \item wyra¿enie, którego obliczenie wywo³a³o wyj±tek.
    \end{itemize}
   \item wyra¿enie zawieraj±ce wywo³ania funkcji:
    \begin{itemize}
     \item wywo³anie funkcji bezargumentowej,
     \item wywo³anie funkcji z argumentami bêd±cymi typami prostymi,
     \item wywo³anie funkcji z argumentami bêd±cymi typami z³o¿onymi,
     \item wywo³anie metody obiektu,
     \item wywo³anie metody statycznej obiektu.
    \end{itemize}
  \end{itemize}
  Wymienione przypadki testowe mo¿na kombinowaæ ze sob± i tworzyæ w nieskoñczono¶æ coraz bardziej z³o¿one wyra¿enia.
  Zaimplementowany zestaw testów pokrywa wszystkie z wymienionych przypadków.
  
  Dla wszystkich przypadków testowych biblioteka uzyska³a wynik pozytywny.
  Pokazuje to, ¿e biblioteka dzia³a poprawnie dla reprezentatywnego zbioru przyk³adów wyra¿eñ w jêzyku C++.
  Pozwala to s±dziæ, ¿e biblioteka potrafi obs³u¿yæ poprawnie dowolne wyra¿enie jêzyka C++.
  
\section{Test wydajno¶ciowy}

  Test wydajno¶ciowy biblioteki zosta³ przeprowadzony przez porównanie czasów wykonania algorytmu szybkiego sortowania (z ang. quicksort) zaimplementowanego sekwencyjnie, przy wykorzystaniu biblioteki Parallel
  lub przy u¿yciu standardowego mechanizmu w±tków Boost Thread.
  Celem testów by³o sprawdzenie prawdziwo¶ci hipotez:
  \begin{itemize}
   \item Programy u¿ywajace biblioteki Parallel dzia³aj± nie wolniej ni¿ programy sekwencyjne.
   \item Odpowiednio napisany program u¿ywajacy biblioteki Parallel w porównaniu z wersj± sekwencyjn± uzyskuje przyspieszenie, które ro¶nie wraz ilo¶ci± procesorów wykorzystanych do obliczeñ.
   \item Czas dzia³ania programów napisanych z wykorzystaniem bibliotek Parallel i Boost Thread jest zbli¿ony, z przewag± biblioteki Parallel wynikaj±cej z zastosowania puli w±tków.
  \end{itemize}
  
  Dla celów testów przyjêto za³o¿enie, ¿e programy bêd± mia³y podobn± strukturê, gdy¿ w przeciwnym przypadku porównywanie ich wydajno¶ci nie mia³oby sensu.
  
\subsection{Parametry testu}

  Do testów wykorzystano tablicê liczb ca³kowitych generowanych przy pomocy liczb pseudolosowych z ustalon± warto¶ci± pocz±tkow±\footnote{Ustalenie warto¶ci pocz±tkowej ci±gu liczb pseudolosowych ma s³u¿yæ powtarzalno¶ci testu.}.
  Tablica mie¶ci³a 200 000 000 liczb ca³kowitych, osi±gaj±c rozmiar oko³o 800 MB.
  
  W ka¿dej z równoleg³ych implementacji zastosowano zasadê ``Dziel i zwyciê¿aj'', to znaczy problem sortowania by³ dzielony na mniejsze, które nastêpnie by³y rozwi±zywane równolegle.
  Fragmenty tablicy poni¿ej 1 000 000 elementów by³y sortowane sekwencyjnie.
  Implementacja testów jest do wgl±du w za³±czonych do pracy plikach ¼ród³owych w folderze parallel/test.
  Ka¿dy z testów zosta³ przeprowadzony 10 razy, a wyniki zosta³y u¶rednione, w celu uniezale¿nienia wyniku od chwilowych wahañ wydajno¶ci komputera.
  
\subsection{Wyniki testu}
  
  Na pocz±tku testy zosta³y przeprowadzone na standardowym komputerze osobistym, dok³adne dane na temat jego parametrów znajduj± siê w dodatku \nameref{c:konfiguracja}.
  Najwa¿niejsz± informacj± jest fakt, i¿ komputer posiada³ procesor wyposa¿ony w dwa rdzenie z funkcj± hiperw±tkowo¶ci, czyli w sumie 4 rdzenie logiczne.
  Limit liczby w±tków dla biblioteki Parallel zosta³ ustalony na 3 (w zwi±zku z tym wliczaj±c w±tek g³owny programu, który równie¿ prowadzi³ obliczenia, otrzymano liczbê w±tków równ± liczbie rdzeni logicznych).

  Oto uzyskane rezultaty testów:
  \begin{itemize}
   \item sortowanie szybkie sekwencyjne: 	36,81 s.
   \item sortowanie szybkie z Boost.Thread: 	21,77 s.
   \item sortowanie szybkie z Parallel: 	21,73 s.
  \end{itemize}

  Maszyna, na której wykonywano testy posiada³a procesor dwurdzeniowy, wiêc teoretycznie maksymalne przyspieszenie wynosi³o 2.
  Przyspieszenie osi±gniête w wyniku zrównoleglenia algorytmu szybkiego sortowania w przypadku obu metod (Parallel i Boost Thread) wynios³o oko³o 1,69.
  
  Dla porównania przeprowadzono identyczne testy na maszynie students nale¿±cej do Wydzia³u Matematyki, Informatyki i Mechaniki Uniwersytetu Warszawskiego.
  Jest ona wyposa¿ona w 23 procesory o 6 rdzeniach ka¿dy\footnote{Zgodnie z informacjami znalezionymi w pliku \texttt{/proc/cpuinfo}}.
  Limit liczby w±tków dla biblioteki zosta³ ustawiony na 40, co, jak wykaza³y próby empiryczne, by³o maksymaln± dozwolon± warto¶ci± dla konfiguracji maszyny students.
  Dla programu korzystaj±cego z Boost Thread fragmenty tablicy poni¿ej 8 000 000 elementów by³y sortowane sekwencyjnie, gdy¿ zmniejszenie tej warto¶ci powodowa³o b³±d wykonania wynikaj±cy z nadmiernej alokacji nowych w±tków.
  Testy zakoñczy³y siê nastêpuj±cymi wynikami:
  \begin{itemize}
   \item sortowanie szybkie sekwencyjne: 	39,19 s.
   \item sortowanie szybkie z Boost Thread: 	8,09 s.
   \item sortowanie szybkie z Parallel: 	5,58 s.
  \end{itemize}
  
  Przyspieszenie dla programu korzystaj±cego z Boost Thread by³o równe 4,84, a w przypadku biblioteki Parallel wynios³o 7,02.
  Biblioteka Parallel w porównaniu z Boost Thread osi±gnê³a w tym te¶cie wyj±tkowo dobry wynik.
  
\subsection{Podsumowanie wyników testu}

  Wyniki przeprowadzonych testów potwierdzi³y postawione hipotezy. 
  Algorytm szybkiego sortowania dzia³a³ po zrównolegleniu znacznie szybciej ni¿ wersja sekwencyjna.
  Uzyskane przyspieszenie ros³o wraz ze wzrostem jednostek obliczeniowych wykorzystanych do wykonania programu.
  Ponadto, czasy wykonania programów na komputerze osobisty zaimplementowanych w oparciu o Parallel i Boost Thread ró¿ni³y siê nieznacznie, z niewielk± przewag± na rzecz biblioteki Parallel.
  Jednak, gdy programy testowe zosta³y uruchomione na maszynie students okaza³o siê, ¿e program korzystaj±cy z biblioteki Parallel wykonywa³ siê znacznie szybciej.
  Ten fakt mo¿e zostaæ czê¶ciowo wyt³umaczony przez zastosowanie puli w±tków w bibliotece Parallel, co pozwoli³o unikn±æ wielu operacji tworzenia nowych w±tków.
  
  Inn± obserwacj± poczynion± podczas przeprowadzania testów by³o b³êdne wykonanie programu korzystaj±cego z biblioteki Boost.Thread, w przypadku zmniejszenia limitu
  rozmiaru tablicy, poni¿ej którego tablica by³a sortowana sekwencyjnie (do 50 000 w przypadku testów na komputerze osobistym, a do 5 000 000 w przypadku wykonania programu testowego na maszynie students). 
  Powodem by³a próba stworzenia wiêkszej liczby w±tków ni¿ pozwala³a na to konfiguracja systemu.
  Dla tych samych parametrów program u¿ywaj±cy Parallel wykonywa³ siê bezb³êdnie.
  
% 
% \section{Ocena realizacji celów}
% 
%   W tej sekcji zosta³ oceniony stopieñ realizacji celów, które zosta³y postawione przed bibliotek± Parallel w sekcji \nameref{s:cele}.
%   Nale¿y mieæ ¶wiadomo¶æ, ¿e ocena realizacji niektórych z celów opiera siê na subiektywnej argumentacji twórcy biblioteki.
%   Dla wiarygodnej oceny spe³nienia celów dotycz±cych zwiêkszenia ³atwo¶ci programowania równoleg³ego przy pomocy biblioteki nale¿y przeprowadziæ badania statystyczne, 
%   które pozwoli³yby wnioskowaæ o tym, jak przeciêtny programista jêzyka C++ ocenia ³atwo¶æ programowania przy u¿yciu Parallel.
%   
% \begin{tabular}{ | l | p{0.75\textwidth} |}
%   \hline\
%   \textbf{Cel} & \textbf{Ocena realizacji} \\ \hline
%   Efektywno¶æ & Konstrukcja jêzyka C++, która czêsto pojawia siê w kodzie lub projektach do¶wiadczonych programistów C++. Stosowanie jej uwa¿ane jest za dobr± praktykê.\\ \hline
%   Produktywno¶æ programisty & Abstrakcyjne Drzewo Syntaktyczne (z ang. Abstract Syntax Tree) jest drzewem reprezentuj±cym strukturê kodu ¼ród³owego w pewnym jêzyku programowania.\\ \hline
%   Czytelno¶æ kodu & \\ \hline
%   Transparencja & \\ \hline
%   Abstrakcja & \\ \hline
%   
%   
%   \hline
% \end{tabular} 
